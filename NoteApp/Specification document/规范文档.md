*Write by 紫枫伊* **2022年4月27日**

# 一、前言

​	本文档针对`NoteApp`应用建立，主要用于定义应用的外观、应用结构、规范代码命名以及对项目编写过程中遇到的问题及处理方式做阶段性的记录。

# 二、`NoteApp`结构梳理

## 2.1 登录逻辑

### 2.1.1 登录页面布局

~~~mermaid
graph TD
0{{登录界面}} --> 1(登录)
0 --> 2(忘记密码)
0 --> 3(注册)
0 --> 4(设置)
~~~

### 2.1.2 登录逻辑

~~~mermaid
graph TB
0[登录] --> 1[/登录判断/] -- 用户账号密码正确 --- 3[登录成功] --- 主界面
1 -- 用户账号或密码错误 --> 登陆失败提示
~~~

### 2.1.3 忘记密码

~~~mermaid
graph
0(忘记密码) --> 1[找回密码] -- 成功找回 --> 登录页面
1 -- 找不回 --> 7[注册页面]
~~~



### 2.1.4 注册逻辑

~~~mermaid
graph
0[注册页面]
0 --- 1[输入用户名] --- 5[用户名查重]
0 --- 2[输入账号] --- 6[账号查重]
0 --- 3[输入密码] .- 7{密文}
0 --- 4(注册) -- 注册成功 .- 9[登录页面]
~~~



# 三、命名规范

## 1、前缀

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

## 2、中间名

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

## 3、后缀

|  格式   |     说明     |           示例           |
| :-----: | :----------: | :----------------------: |
| `-Dev`  | 表示开发环境 |       `NoteAppDev`       |
|  -View  | 表示视图窗口 | `LoginMainView` 登录主页 |
| -Window |   表示窗体   |    `MainWindow`主窗体    |



# 四、页面布局

## 3.1 登录页面

![登录界面布局 Height="414" Width="540"](.\images\规范文档\QQ图片20220428085133.png)





# 五、项目日记

|     日期      |               操作                |                 备注                 |
| :-----------: | :-------------------------------: | :----------------------------------: |
| 2022年4月27日 |         新建`NoteApp`项目         |      语言框架使用.Net Core 6.0       |
| 2022年4月27日 |           新建规范文档            |  Specification document - 规范文档   |
| 2022年4月27日 |         登录页面逻辑规划          |                                      |
| 2022年4月27日 |    `NoteApp`添加`Views`文件夹     |           用于存放各种界面           |
| 2022年4月28日 |           导入`Prism`包           |       项目组要使用`prism`框架        |
| 2022年4月28日 |  `Views`文件夹中新建`LoginViews`  |       用来存放登录界面各项控件       |
| 2022年4月28日 |      新建`LoginMainView`页面      |              登录主页面              |
| 2022年4月28日 | 配置`App.xaml`和`App.xaml.cs`文件 |      主页指向到`LoginMainView`       |
| 2022年4月28日 |     删除`MainWindow.xaml`文件     |                                      |
| 2022年4月28日 |      导入`MaterialDesign`包       |             用于页面美化             |
| 2022年4月28日 |        配置`App.xaml`文件         | 在全局字典中引用`materialDesign`资源 |
| 2022年4月30日 | 弃用项目，使用`Prism`模板新建项目 |                                      |
|               |                                   |                                      |
|               |                                   |                                      |



# 六、代码整理

## 5.1 项目结构

~~~mermaid

~~~

## 5.2 代码展示

### 5.2.1 数据表实体类

```c#
 /// <summary>
/// 基础实体类
/// </summary>
public class BaseEntity
{
    /// <summary>
    /// Base Id
    /// </summary>
    [Column(Order = 0)]
    public int Id { get; set; }
    /// <summary>
    /// Base 可用性
    /// </summary>
    [Column(Order = 1)]
    public bool IsEnable { get; set; }
    /// <summary>
    /// Base 创建时间
    /// </summary>
    [Column(Order = 2)]
    public DateTime GreateTime { get; set; }
    /// <summary>
    /// Base 更新时间
    /// </summary>
    [Column(Order = 3)]
    public DateTime UpdateTime { get; set; }
}


[Table("users")]
public class User : BaseEntity
{
    [Required] //非空
    [Column(TypeName = "varchar(100)")]
    [Comment("用户名")] //注释
    public string? UserName { get; set; }
    [Required]
    [Column(TypeName = "varchar(100)")]
    public string? Password { get; set; }
    [Required]
    [MaxLength(11)] // 最大长度
    [Column("手机号码")]
    public string? TelphoneNumber { get; set; }
}
```



# 七、问题梳理

|           问题           |                             描述                             |                           处理方法                           |
| :----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| Controller找不到服务接口 | ```System.InvalidOperationException: Unable to resolve service for type 'NoteApp.Api.Services.INoteAppService' while attempting to activate 'NoteApp.Api.Controllers.NoteAppController'.``` | `program`文件中把服务与对应接口绑定<br />```builder.Services.AddTransient<INoteAppService, NoteAppService>();``` |
|                          |                                                              |                                                              |
|                          |                                                              |                                                              |



# 八、知识点归纳

## 8.1 教程：使用 ASP.NET Core 创建最小 Web API

- 项目 2022/05/05 6 个参与者
- 作者：[Rick Anderson](https://twitter.com/RickAndMSFT)

​	构建最小 API，以创建具有最小依赖项的 HTTP API。 它们非常适合于需要在 ASP.NET Core 中仅包括最少文件、功能和依赖项的微服务和应用。

​	本教程介绍使用 ASP.NET Core 生成最小 Web API 的基础知识。 有关基于包含更多功能的[控制器](https://docs.microsoft.com/zh-cn/aspnet/core/web-api/?view=aspnetcore-6.0)创建 Web API 项目的教程，请参阅[创建 Web API](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/first-web-api?view=aspnetcore-6.0)。

### 概述

​	本教程将创建以下 API：

| API                       | 描述                      | 请求正文 | 响应正文       |
| :------------------------ | :------------------------ | :------- | :------------- |
| `GET /`                   | 浏览器测试，“Hello World” | 无       | Hello World!   |
| `GET /todoitems`          | 获取所有待办事项          | None     | 待办事项的数组 |
| `GET /todoitems/complete` | 获取已完成的待办事项      | None     | 待办事项的数组 |
| `GET /todoitems/{id}`     | 按 ID 获取项              | None     | 待办事项       |
| `POST /todoitems`         | 添加新项                  | 待办事项 | 待办事项       |
| `PUT /todoitems/{id}`     | 更新现有项                | 待办事项 | None           |
| `DELETE /todoitems/{id}`  | 删除项                    | 无       | 无             |

### 先决条件

- [Visual Studio](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_1_visual-studio)
- [Visual Studio Code](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_1_visual-studio-code)

- 带有 ASP.NET 和 Web 开发工作负载的 [Visual Studio 2022](https://visualstudio.microsoft.com/vs/#download)。

![image-20220524162358124](.\images\规范文档\image-20220524162358124.png)

### 创建 Web API 项目

- [Visual Studio](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_2_visual-studio)
- [Visual Studio Code](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_2_visual-studio-code)
- 启动 Visual Studio 2022 并选择“创建新项目”。
- 在“创建新项目”对话框中：
  - 在“搜索模板”搜索框中输入 `API`。
  - 选择“ASP.NET Core Web API”模板，然后选择“下一步”。 

![image-20220524162835421](.\images\规范文档\image-20220524162835421.png)

- 将项目命名为 TodoApi，然后选择“下一步”。
- 在“其他信息”对话框中：
  - 选择“.NET 6.0 (长期支持)”
  - 删除“使用控制器(取消选中以使用最小 API)”
  - 选择“创建”

![image-20220524163104955](.\images\规范文档\image-20220524163104955.png)

#### 检查代码

`Program.cs` 文件包含以下代码：

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

var summaries = new[]
{
    "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
};

app.MapGet("/weatherforecast", () =>
{
    var forecast = Enumerable.Range(1, 5).Select(index =>
       new WeatherForecast
       (
           DateTime.Now.AddDays(index),
           Random.Shared.Next(-20, 55),
           summaries[Random.Shared.Next(summaries.Length)]
       ))
        .ToArray();
    return forecast;
})
.WithName("GetWeatherForecast");

app.Run();

internal record WeatherForecast(DateTime Date, int TemperatureC, string? Summary)
{
    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
}
```

项目模板创建了一个支持 [Swagger](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0) 的 `WeatherForecast` API。 Swagger 用于为 Web API 生成有用的文档和帮助页面。

以下突出显示的代码添加了对 Swagger 的支持：

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
```

#### 运行应用

- [Visual Studio](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_3_visual-studio)
- [Visual Studio Code](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_3_visual-studio-code)

按 Ctrl+F5 以在不使用调试程序的情况下运行。

Visual Studio 会显示以下对话框：

![This project is configured to use SSL. To avoid SSL warnings in the browser you can choose to trust the self-signed certificate that IIS Express has generated. Would you like to trust the IIS Express SSL certificate?](https://docs.microsoft.com/zh-cn/aspnet/core/getting-started/_static/trustcertvs22.png?view=aspnetcore-6.0)

如果信任 IIS Express SSL 证书，请选择“是”。

将显示以下对话框：

![Security warning dialog](https://docs.microsoft.com/zh-cn/aspnet/core/getting-started/_static/cert.png?view=aspnetcore-6.0)

如果你同意信任开发证书，请选择“是”。

有关信任 Firefox 浏览器的信息，请参阅 [Firefox SEC_ERROR_INADEQUATE_KEY_USAGE 证书错误](https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-6.0#trust-ff)。

Visual Studio 启动 [Kestrel Web s服务器](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-6.0)。

随即显示 Swagger 页面 `/swagger/index.html`。 选择 **`GET > Try it out> Execute`**。 页面将显示：

- 用于测试 WeatherForecast API 的 [Curl](https://curl.haxx.se/) 命令。
- 用于测试 WeatherForecast API 的 URL。
- 响应代码、正文和标头。
- 包含媒体类型、示例值和架构的下拉列表框。

将请求 URL 复制粘贴到浏览器中：`https://localhost:<port>/WeatherForecast`。 返回类似于以下项的 JSON：

```json
[
  {
    "date": "2021-10-19T14:12:50.3079024-10:00",
    "temperatureC": 13,
    "summary": "Bracing",
    "temperatureF": 55
  },
  {
    "date": "2021-10-20T14:12:50.3080559-10:00",
    "temperatureC": -8,
    "summary": "Bracing",
    "temperatureF": 18
  },
  {
    "date": "2021-10-21T14:12:50.3080601-10:00",
    "temperatureC": 12,
    "summary": "Hot",
    "temperatureF": 53
  },
  {
    "date": "2021-10-22T14:12:50.3080603-10:00",
    "temperatureC": 10,
    "summary": "Sweltering",
    "temperatureF": 49
  },
  {
    "date": "2021-10-23T14:12:50.3080604-10:00",
    "temperatureC": 36,
    "summary": "Warm",
    "temperatureF": 96
  }
]
```

### 更新生成的代码

本教程重点介绍如何创建 Web API，以便删除 Swagger 代码和 `WeatherForecast` 代码。 将 `Program.cs` 文件的内容替换为以下内容：

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

以下突出显示的代码创建具有预配置默认值的 [WebApplicationBuilder](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) 和 [WebApplication](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.builder.webapplication)：

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

以下代码创建返回 `Hello World!` 的 HTTP GET 终结点 `/`：

```csharp
app.MapGet("/", () => "Hello World!");
```

`app.Run();` 运行应用。

从 `Properties/launchSettings.json` 文件中删除两个 `"launchUrl": "swagger",` 行。 如果未指定 `launchUrl`，Web 浏览器将请求 `/` 终结点。

运行应用。 此时将显示 `Hello World!`。 更新后的 `Program.cs` 文件包含一个最小但完整的应用。

### 添加 NuGet 包

必须添加 NuGet 包以支持本教程中使用的数据库和诊断。

- [Visual Studio](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_4_visual-studio)
- [Visual Studio Code](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_4_visual-studio-code)

- 在“工具”菜单中，选择“NuGet 包管理器”>“管理解决方案的 NuGet 包”。
- 在搜索框中输入“Microsoft.EntityFrameworkCore.InMemory”，然后选择 `Microsoft.EntityFrameworkCore.InMemory`。
- 选中右窗格中的“项目”复选框，然后选择“安装” 。
- 按照上述说明添加 `Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore` 包。

### 添加 API 代码

将 `Program.cs` 文件的内容替换为以下代码：

```csharp
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<TodoDb>(opt => opt.UseInMemoryDatabase("TodoList"));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.MapGet("/todoitems", async (TodoDb db) =>
    await db.Todos.ToListAsync());

app.MapGet("/todoitems/complete", async (TodoDb db) =>
    await db.Todos.Where(t => t.IsComplete).ToListAsync());

app.MapGet("/todoitems/{id}", async (int id, TodoDb db) =>
    await db.Todos.FindAsync(id)
        is Todo todo
            ? Results.Ok(todo)
            : Results.NotFound());

app.MapPost("/todoitems", async (Todo todo, TodoDb db) =>
{
    db.Todos.Add(todo);
    await db.SaveChangesAsync();

    return Results.Created($"/todoitems/{todo.Id}", todo);
});

app.MapPut("/todoitems/{id}", async (int id, Todo inputTodo, TodoDb db) =>
{
    var todo = await db.Todos.FindAsync(id);

    if (todo is null) return Results.NotFound();

    todo.Name = inputTodo.Name;
    todo.IsComplete = inputTodo.IsComplete;

    await db.SaveChangesAsync();

    return Results.NoContent();
});

app.MapDelete("/todoitems/{id}", async (int id, TodoDb db) =>
{
    if (await db.Todos.FindAsync(id) is Todo todo)
    {
        db.Todos.Remove(todo);
        await db.SaveChangesAsync();
        return Results.Ok(todo);
    }

    return Results.NotFound();
});

app.Run();

class Todo
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
}

class TodoDb : DbContext
{
    public TodoDb(DbContextOptions<TodoDb> options)
        : base(options) { }

    public DbSet<Todo> Todos => Set<Todo>();
}
```

### 模型和数据库上下文类

示例应用包含以下模型：

```csharp
class Todo
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
}
```

模型是一个表示应用管理的数据的类。 此应用的模型是 `Todo` 类。

示例应用还包含以下数据库上下文类：

```csharp
class TodoDb : DbContext
{
    public TodoDb(DbContextOptions<TodoDb> options)
        : base(options) { }

    public DbSet<Todo> Todos => Set<Todo>();
}
```

数据库上下文是为数据模型协调 [Entity Framework](https://docs.microsoft.com/zh-CN/ef/core/) 功能的主类。 此类由 [Microsoft.EntityFrameworkCore.DbContext](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.entityframeworkcore.dbcontext) 类派生而来。

以下突出显示的代码将数据库上下文添加到[依赖关系注入 (DI)](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-6.0) 容器，并且允许显示与数据库相关的异常：

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<TodoDb>(opt => opt.UseInMemoryDatabase("TodoList"));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();
var app = builder.Build();
```

DI 容器提供对数据库上下文和其他服务的访问权限。

以下代码创建 HTTP POST 终结点 `/todoitems` 以将数据添加到内存中数据库：

```csharp
app.MapPost("/todoitems", async (Todo todo, TodoDb db) =>
{
    db.Todos.Add(todo);
    await db.SaveChangesAsync();

    return Results.Created($"/todoitems/{todo.Id}", todo);
});
```

### 安装 Postman 以测试应用

本教程使用 Postman 测试 Web API。

- 安装 [Postman](https://www.getpostman.com/downloads/)

- 启动 Web 应用。

- 启动 Postman。

- 禁用

  SSL 证书验证

  - 在“文件”>“设置”（“常规”选项卡）中，禁用“SSL 证书验证” 。

     警告

    在测试控制器之后重新启用 SSL 证书验证。



### 测试发布数据

以下说明将数据发布到应用：

- 创建新请求。

- 将 HTTP 方法设置为 `POST`。

- 将 URI 设置为 `https://localhost:<port>/todoitems`。 例如： `https://localhost:5001/todoitems`

- 选择“正文”选项卡。

- 选择“raw”。

- 将类型设置为“JSON”。

- 在请求正文中，输入待办事项的 JSON：

  ```json
  {
    "name":"walk dog",
    "isComplete":true
  }
  ```
  
- 选择**Send**。 ![Postman with Post request details](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api/_static/post2.png?view=aspnetcore-6.0)

### 检查 GET 终结点

示例应用使用对 `MapGet` 的调用实现多个 GET 终结点：

| API                   | 描述                      | 请求正文 | 响应正文       |
| :-------------------- | :------------------------ | :------- | :------------- |
| `GET /`               | 浏览器测试，“Hello World” | 无       | `Hello World!` |
| `GET /todoitems`      | 获取所有待办事项          | None     | 待办事项的数组 |
| `GET /todoitems/{id}` | 按 ID 获取项              | None     | 待办事项       |

```csharp
app.MapGet("/", () => "Hello World!");

app.MapGet("/todoitems", async (TodoDb db) =>
    await db.Todos.ToListAsync());

app.MapGet("/todoitems/complete", async (TodoDb db) =>
    await db.Todos.Where(t => t.IsComplete).ToListAsync());

app.MapGet("/todoitems/{id}", async (int id, TodoDb db) =>
    await db.Todos.FindAsync(id)
        is Todo todo
            ? Results.Ok(todo)
            : Results.NotFound());
```

### 测试 GET 终结点

通过从浏览器或 Postman 调用两个终结点来测试应用。 例如：

- `GET https://localhost:5001/todoitems`
- `GET https://localhost:5001/todoitems/1`

对 `GET /todoitems` 的调用生成如下响应：

```json
[
  {
    "id": 1,
    "name": "Item1",
    "isComplete": false
  }
]
```

#### 使用 Postman 测试 GET 终结点

- 创建新请求。
- 将 HTTP 方法设置为“GET”。
- 将请求 URI 设置为 `https://localhost:<port>/todoitems`。 例如 `https://localhost:5001/todoitems`。
- 选择**Send**。

此应用使用内存中数据库。 如果已重新启动应用，GET 请求不会返回任何数据。 如果未返回任何数据，则首先使用 [POST](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#post) 将数据发布到应用。

### 返回值

ASP.NET Core 自动将对象序列化为 [JSON](https://www.json.org/)，并将 JSON 写入响应消息的正文中。 此返回类型的响应代码为 [200 OK](https://developer.mozilla.org/docs/Web/HTTP/Status/200)（假设没有未处理的异常）。 未经处理的异常将转换为 5xx 错误。

返回类型可以表示大范围的 HTTP 状态代码。 例如，`GET /todoitems/{id}` 可以返回两个不同的状态值：

- 如果没有任何项与请求的 ID 匹配，该方法将返回 [404 状态](https://developer.mozilla.org/docs/Web/HTTP/Status/404)[NotFound](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.notfound)错误代码。
- 否则，此方法将返回具有 JSON 响应正文的 200。 返回 `item` 则产生 HTTP 200 响应。

### 检查 PUT 终结点

示例应用使用 `MapPut` 实现单个 PUT 终结点：

```csharp
app.MapPut("/todoitems/{id}", async (int id, Todo inputTodo, TodoDb db) =>
{
    var todo = await db.Todos.FindAsync(id);

    if (todo is null) return Results.NotFound();

    todo.Name = inputTodo.Name;
    todo.IsComplete = inputTodo.IsComplete;

    await db.SaveChangesAsync();

    return Results.NoContent();
});
```

此方法类似于 `MapPost` 方法，但它使用 HTTP PUT。 成功响应返回 [204 (无内容)](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)。 根据 HTTP 规范，PUT 请求需要客户端发送整个更新的实体，而不仅仅是更改。 若要支持部分更新，请使用 [HTTP PATCH](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.httppatchattribute)。

#### 测试 PUT 终结点

本示例使用内存内、数据库，每次启动应用时都必须对其进行初始化。 在进行 PUT 调用之前，数据库中必须有一个项。 调用 GET，以确保在调用 PUT 之前数据库中存在项。

更新 ID 为 1 的待办事项并将其名称设置为 `"feed fish"`：

```json
{
  "Id": 1,
  "name": "feed fish",
  "isComplete": false
}
```

### 检查 DELETE 终结点

示例应用使用 `MapDelete` 实现单个 DELETE 终结点：

```csharp
app.MapDelete("/todoitems/{id}", async (int id, TodoDb db) =>
{
    if (await db.Todos.FindAsync(id) is Todo todo)
    {
        db.Todos.Remove(todo);
        await db.SaveChangesAsync();
        return Results.Ok(todo);
    }

    return Results.NotFound();
});
```

使用 Postman 删除待办事项：

- 将方法设置为 `DELETE`。
- 设置要删除的对象的 URI，例如 `https://localhost:5001/todoitems/1`。
- 选择**Send**。



### 防止过度发布

目前，示例应用公开了整个 `Todo` 对象。 生产应用通常使用模型的子集来限制输入和返回的数据。 这背后有多种原因，但安全性是主要原因。 模型的子集通常称为数据传输对象 (DTO)、输入模型或视图模型。 本文使用的是 **DTO**。

DTO 可用于：

- 防止过度发布。
- 隐藏客户端不应查看的属性。
- 省略一些属性以缩减有效负载大小。
- 平展包含嵌套对象的对象图。 对客户端而言，平展的对象图可能更方便。

若要演示 DTO 方法，请更新 `Todo` 类，使其包含机密字段：

```csharp
public class Todo
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
    public string? Secret { get; set; }
}
```

此应用需要隐藏机密字段，但管理应用可以选择公开它。

确保可以发布和获取机密字段。

创建 DTO 模型：

```csharp
public class TodoItemDTO
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }

    public TodoItemDTO() { }
    public TodoItemDTO(Todo todoItem) =>
    (Id, Name, IsComplete) = (todoItem.Id, todoItem.Name, todoItem.IsComplete);
}
```

更新代码以使用 `TodoItemDTO`：

```csharp
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDatabaseDeveloperPageExceptionFilter();
builder.Services.AddDbContext<TodoDb>(opt => opt.UseInMemoryDatabase("TodoList"));
var app = builder.Build();

app.MapGet("/todoitems", async (TodoDb db) =>
    await db.Todos.Select(x => new TodoItemDTO(x)).ToListAsync());

app.MapGet("/todoitems/{id}", async (int id, TodoDb db) =>
    await db.Todos.FindAsync(id)
        is Todo todo
            ? Results.Ok(new TodoItemDTO(todo))
            : Results.NotFound());

app.MapPost("/todoitems", async (TodoItemDTO todoItemDTO, TodoDb db) =>
{
    var todoItem = new Todo
    {
        IsComplete = todoItemDTO.IsComplete,
        Name = todoItemDTO.Name
    };

    db.Todos.Add(todoItem);
    await db.SaveChangesAsync();

    return Results.Created($"/todoitems/{todoItem.Id}", new TodoItemDTO(todoItem));
});

app.MapPut("/todoitems/{id}", async (int id, TodoItemDTO todoItemDTO, TodoDb db) =>
{
    var todo = await db.Todos.FindAsync(id);

    if (todo is null) return Results.NotFound();

    todo.Name = todoItemDTO.Name;
    todo.IsComplete = todoItemDTO.IsComplete;

    await db.SaveChangesAsync();

    return Results.NoContent();
});

app.MapDelete("/todoitems/{id}", async (int id, TodoDb db) =>
{
    if (await db.Todos.FindAsync(id) is Todo todo)
    {
        db.Todos.Remove(todo);
        await db.SaveChangesAsync();
        return Results.Ok(new TodoItemDTO(todo));
    }

    return Results.NotFound();
});

app.Run();

public class Todo
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
    public string? Secret { get; set; }
}

public class TodoItemDTO
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }

    public TodoItemDTO() { }
    public TodoItemDTO(Todo todoItem) =>
    (Id, Name, IsComplete) = (todoItem.Id, todoItem.Name, todoItem.IsComplete);
}


class TodoDb : DbContext
{
    public TodoDb(DbContextOptions<TodoDb> options)
        : base(options) { }

    public DbSet<Todo> Todos => Set<Todo>();
}
```

确保无法发布或获取机密字段。

### 最小 API 与具有控制器的 API 之间的差异

- 不支持筛选器：例如，不支持 [IAsyncAuthorizationFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncauthorizationfilter)、[IAsyncActionFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncactionfilter)、[IAsyncExceptionFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncexceptionfilter)、[IAsyncResultFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncresultfilter) 和 [IAsyncResourceFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncresourcefilter)。

- 不支持模型绑定，即`ModelBinderProvider`、`IModelBinder`。 可以使用自定义绑定填充码添加支持。

  - 不支持从窗体进行绑定。 这包括绑定 [IFormFile](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.http.iformfile)。 我们计划在将来添加对 `IFormFile` 的支持。

- 没有对验证的内置支持，即 [IModelValidator](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.modelbinding.validation.imodelvalidator)

- 不支持[应用程序部件](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/advanced/app-parts?view=aspnetcore-6.0)或[应用程序模型](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/application-model?view=aspnetcore-6.0)。 无法应用或生成自己的约定。

- 没有内置视图呈现支持。 建议使用 [Razor Pages](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/razor-pages/razor-pages-start?view=aspnetcore-6.0) 呈现视图。

- 不支持 [JsonPatch](https://www.nuget.org/packages/Microsoft.AspNetCore.JsonPatch/)

- 不支持 [OData](https://www.nuget.org/packages/Microsoft.AspNetCore.OData/)

- 不支持 [ApiVersioning](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Versioning/)。 如需更多详细信息，请参阅[此问题](https://github.com/dotnet/aspnet-api-versioning/issues/751)。

### 使用 JsonOptions

以下代码使用 [JsonOptions](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.http.json.jsonoptions)：

```csharp
using Microsoft.AspNetCore.Http.Json;

var builder = WebApplication.CreateBuilder(args);

// Configure JSON options
builder.Services.Configure<JsonOptions>(options =>
{
    options.SerializerOptions.IncludeFields = true;
});

var app = builder.Build();

app.MapGet("/", () => new Todo { Name = "Walk dog", IsComplete = false });

app.Run();

class Todo
{
    // These are public fields instead of properties.
    public string? Name;
    public bool IsComplete;
}
```

以下代码使用 [JsonSerializerOptions](https://docs.microsoft.com/zh-CN/dotnet/api/system.text.json.jsonserializeroptions)：

```csharp
using System.Text.Json;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var options = new JsonSerializerOptions(JsonSerializerDefaults.Web);

app.MapGet("/", () => Results.Json(new Todo {
                      Name = "Walk dog", IsComplete = false }, options));

app.Run();

class Todo
{
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
}
```

上述代码使用 [Web 默认值](https://docs.microsoft.com/zh-CN/dotnet/standard/serialization/system-text-json-configure-options#web-defaults-for-jsonserializeroptions)，它将属性名称转换为 camel 大小写。

### 测试最小 API

有关测试最小 API 应用的示例，请参阅[此 GitHub 示例](https://github.com/davidfowl/CommunityStandUpMinimalAPI/blob/main/TodoApi.Tests/TodoTests.cs)。

### 发布到 Azure

有关部署到 Azure 的信息，请参阅[快速入门：部署 ASP.NET Web 应用](https://docs.microsoft.com/zh-CN/azure/app-service/quickstart-dotnetcore)。

### 其他资源

- [最小 API 概述](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-6.0)



## 8.2 使用 Entity Framework Core 保留和检索关系数据

### 了解 EF Core

Entity Framework Core 是对象-关系映射程序。 ORM 在代码和数据库中实现域模型之间提供一个层。 EF Core 是一种数据访问 API，允许你使用 .NET POCO（普通旧 CLR 对象）和强类型 LINQ 与数据库进行交互。 这样，你可以花更少的时间与数据库之间转换请求以及编写 SQL，从而让你有更多时间专注于重要的业务逻辑。

使用 EF Core，数据库在 .NET POCO 后面抽象化。 因此，你可以专注于代码，EF Core 处理与基础数据库的直接交互。

使用 EF Core，可以：

- 将数据作为 C# 对象（实体）加载。
- 通过调用这些实体上的方法来添加、修改和删除数据。
- 将多个数据库表映射到单个 C# 实体。
- 处理多个用户同时尝试更新同一记录时出现的并发问题。
- 使用强类型语言集成查询 ([System.Linq](https://docs.microsoft.com/zh-cn/dotnet/api/system.linq)) 语法来查询数据库。
- 访问[多个数据库](https://docs.microsoft.com/zh-cn/ef/core/providers/)，包括 SQL Server、Sqlite、Azure Cosmos DB、PostgreSQL、MySQL 等。
- 从现有数据库生成域模型。
- 根据域模型管理数据库架构。
- 使用单个方法调用提交对相关实体的复杂、深层和/或宽对象图的更改。

### 查看 EF Core 体系结构

下图描述了 EF Core 背后的体系结构。

![ef-core-architecture](.\images\规范文档\ef-core-architecture.png)

[DbContext](https://docs.microsoft.com/zh-cn/ef/core/dbcontext-configuration) 是一个特殊类，它表示工作单元，并提供配置选项、连接字符串、日志记录以及用于将域映射到数据库的模型的方法。 派生自 `DbContext` 的类：

- 表示与数据库之间的活动会话。
- 保存和查询实体的实例。
- 包括 `DbSet<T>` 类型的属性，其表示数据库中的表。

EF Core 提供程序将对象图更改转换为 SQL。

数据库提供程序：

- 是面向特定数据库引擎（例如 SQL Server、Azure Cosmos DB 或 PostgreSQL）的插件库。
- 将方法调用和 LINQ 查询转换为数据库的本机 SQL 方言。
- 扩展 EF Core 以启用数据库引擎特有的功能。

#### 管理数据库架构

EF Core 提供两种主要方法来保持 EF Core 模型和数据库架构同步。至于我们应该选用哪个方法，请确定你是希望以 EF Core 模型为准还是以数据库架构为准。

#### 迁移（以模型为准）

在现实世界的项目中，数据模型会随着应用功能的实现而变化。 随着新实体的添加和删除，需要相应地更改数据库架构。 EF Core 迁移提供了一种增量更新数据库架构的方法，使数据库架构与应用程序的数据模型保持同步，同时保留数据库中的现有数据。

引入数据模型更改时，开发人员使用 EF Core 工具添加相应的迁移。 EF Core 将当前模型与旧模型的快照进行比较以确定差异。 将生成用于实现更改的 C# 代码。 可以针对自定义行为或种子数据修改 C# 文件，并像任何其他源文件一样在项目的源代码管理中进行跟踪。

生成新的迁移后，可通过多种方式将其应用于数据库。 EF Core 将所有应用的迁移记录在一个特殊的历史记录表中。 历史记录表记录了已应用的迁移。

#### 反向工程（以数据库为准）

反向工程是基于数据库架构搭建实体模型类和 `DbContext` 类基架的过程。 此方法通常与 DBA 管理的现有数据库或共享数据库一起使用。

### 练习 - 迁移

在本单元中，将创建将映射到本地 SQLite 数据库中的表的 C# 实体类。 EF 迁移将根据这些实体生成表。 通过迁移，能够以增量方式更新数据库架构。

 备注

本模块使用 [.NET CLI（命令行接口）](https://docs.microsoft.com/zh-cn/dotnet/core/tools/)和 [Visual Studio Code](https://code.visualstudio.com/) 进行本地开发。 完成本模块后，你可以使用 Visual Studio (Windows)、Visual Studio for Mac (macOS) 等开发环境来应用其概念，或使用 Visual Studio Code（Windows、Linux 和 macOS）进行持续开发。

此模块使用 .NET 6.0 SDK。 通过在首选终端中运行以下命令，确保你已安装 .NET 6.0：

```dotnetcli
dotnet --list-sdks
```

将显示类似于下面的输出：

```console
3.1.100 [C:\program files\dotnet\sdk]
5.0.100 [C:\program files\dotnet\sdk]
6.0.100 [C:\program files\dotnet\sdk]
```

确保列出了以 `6` 开头的版本。 如果未列出任何版本或未找到命令，请[安装最新的 .NET 6.0 SDK](https://dotnet.microsoft.com/download)。

### 获取起始代码

1. 从终端运行以下命令，克隆起始代码存储库：

   ```cmd
git clone https://github.com/MicrosoftDocs/mslearn-persist-data-ef-core
   ```
   
   上述命令创建起始代码存储库的本地副本。 该应用管理披萨、配料和酱汁。

2. 切换到克隆的存储库中的 `ContosoPizza` 目录，然后在 Visual Studio Code 中打开它。

   ```cmd
   cd mslearn-persist-data-ef-core\ContosoPizza
   code .
   ```
   
3. 查看代码：

   - 该项目是 ASP.NET Core Web API。
   - Services/PizzaService.cs 是定义 CRUD（创建、读取、更新和删除）方法的服务类。 所有方法当前均引发 `System.NotImplementedException`。
   - 在 Program.cs 中，`PizzaService` 注册到 ASP.NET Core 的依赖项注入系统。
   - Controllers/PizzaController.cs 是一个 `ApiController`，它公开了 HTTP POST、GET、PUT 和 DELETE 谓词的终结点。 这些谓词在 `PizzaService` 上调用相应的 CRUD 方法。 `PizzaService` 注入到 `PizzaController` 的构造函数中。
   - Models 文件夹包含 `PizzaService` 和 `PizzaController` 使用的模型。
   - 实体模型 Pizza.cs、Topping.cs 和 Sauce.cs 具有以下关系：
     - 一个披萨可能有一种或多种配料。
     - 一种配料可用于一个或多个披萨。
     - 一个披萨可能有一种酱汁，但一种酱汁可用于许多披萨。

4. 打开 Visual Studio Code 终端 (Ctrl+`)。 使用以下命令生成应用：

   ```dotnetcli
   dotnet build
   ```
   
   代码应生成，无警告或错误。

### 添加 NuGet 包和 EF Core 工具

在开始之前，需要添加所需的包。

1. 从终端运行以下命令：

   ```dotnetcli
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
   ```
   
   此命令将添加包含 EF Core Sqlite 数据库提供程序及其所有依赖项的 NuGet 包，包括常见的 EF Core 服务。

2. 从终端运行以下命令：

   ```dotnetcli
dotnet add package Microsoft.EntityFrameworkCore.Design
   ```
   
   此命令添加 EF Core 工具所需的包。

3. 从终端运行以下命令：

   ```dotnetcli
   dotnet tool install --global dotnet-ef
   ```
   
   此命令将安装 `dotnet ef`，用于创建迁移和基架的工具。

   * **提示** : 如果已安装 `dotnet ef`，则可以使用 `dotnet tool update --global dotnet-ef` 对其进行更新。

### 绑定模型和 DbContext

现在，你将添加并配置一个 `DbContext` 实现，该实现将用作你将与数据库进行交互的网关。

1. 在项目根目录中，添加一个名为 Data 的新文件夹。

2. 在 Data 目录中，创建一个名为 PizzaContext.cs 的新文件。 将以下代码添加到空文件中：

   ```csharp
   using Microsoft.EntityFrameworkCore;
   using ContosoPizza.Models;
   
   namespace ContosoPizza.Data;
   
   public class PizzaContext : DbContext
   {
       public PizzaContext (DbContextOptions<PizzaContext> options)
           : base(options)
       {
       }
   
       public DbSet<Pizza> Pizzas => Set<Pizza>();
       public DbSet<Topping> Toppings => Set<Topping>();
       public DbSet<Sauce> Sauces => Set<Sauce>();
   }
   ```
   
   在上述代码中：

   - 构造函数接受类型为 `DbContextOptions<PizzaContext>` 的参数。 这允许外部代码传入配置，因此可以在测试和生产代码之间共享相同的 `DbContext`，甚至可以与不同的提供程序一起使用。
   - `DbSet<T>` 属性对应于要在数据库中创建的表。
   - 表名称将匹配 `PizzaContext` 类中的 `DbSet<T>` 属性名称。 如果需要，可以重写此行为。
   - 实例化时，`PizzaContext` 将公开 `Pizzas`、`Toppings` 和 `Sauces` 属性。 对这些属性公开的集合所做的更改将传播到数据库。
   
3. 在 Program.cs 中，将 `// Add the PizzaContext` 替换为以下代码：

   ```csharp
   builder.Services.AddSqlite<PizzaContext>("Data Source=ContosoPizza.db");
   ```
   
   前面的代码：

   - 向 ASP.NET Core 的依赖项注入系统注册 `PizzaContext`。
- 指定 `PizzaContext` 将使用 Sqlite 数据库提供程序。
   - 定义指向本地文件 ContosoPizza.db 的 Sqlite 连接字符串。
   
    备注

   对于使用本地数据库文件的 Sqlite，或许可以像这样对连接字符串进行硬编码。 但是，对于 PostgreSQL 或 SQL Server 等网络数据库，应始终安全地存储连接字符串。 对于本地开发，请使用[机密管理器](https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets)。 对于生产部署，请考虑使用 [Azure Key Vault](https://docs.microsoft.com/zh-cn/aspnet/core/security/key-vault-configuration) 之类的服务。

4. 同样在 Program.cs 中，将 `// Additional using declarations` 替换为以下代码。

   ```csharp
using ContosoPizza.Data;
   ```
   
   前面的代码解决了上一步中的依赖关系。

5. 保存所有更改并生成应用。

### 创建并运行迁移

已经完成了创建迁移所需的所有操作，该迁移用于创建初始数据库。

1. 运行以下命令，生成用于创建数据库表的迁移：

   ```dotnetcli
   dotnet ef migrations add InitialCreate --context PizzaContext
   ```
   
   在上述命令中：

   - 迁移被命名为 *InitialCreate*。
- `--context` 选项指定 *ContosoPizza* 项目中的类的名称，该名称派生自 `DbContext`。
  
   *ContosoPizza* 项目根中显示新的 *Migrations* 目录。 该目录包含 *<timestamp>_InitialCreate.cs* 文件，该文件描述了要转换为数据定义语言 (DDL) 更改脚本的数据库更改。

2. 运行以下命令，应用 *InitialCreate* 迁移：

   ```dotnetcli
   dotnet ef database update --context PizzaContext
   ```
   
   执行上述命令将应用迁移。 由于 ContosoPizza.db 不存在，因此在项目目录中创建它。

    提示

   所有平台均支持 `dotnet ef` 工具。 在 Windows 上的 Visual Studio 中，还可以在集成的“包管理器控制台”窗口中使用 `Add-Migration` 和 `Update-Database` PowerShell cmdlet。

### 检查数据库

EF Core 为应用创建了一个数据库。 让我们看看数据库内部。

1. 在 Visual Studio Code 中，按 Ctrl+Shift+X 打开“扩展”选项卡。
2. 在搜索框中，搜索 `vscode-sqlite`。 显示社区提供的 Sqlite 扩展。
3. 如果需要，安装该扩展。
4. 按 Ctrl+Shift+E 返回到“资源管理器”选项卡。
5. 右键单击 ContosoPizza.db 文件。 选择“打开数据集”。

![open-database](.\images\规范文档\open-database.png)

“SQLite 资源管理器”窗格将在“资源管理器”选项卡上打开。

![sqlite-pane](.\images\规范文档\sqlite-pane.png)

展开“SQLite 资源管理器”窗格及其所有子节点。 右键单击 ContosoPizza.db。 选择“显示表 'sqlite_master'”以查看完整的数据库架构和约束。

![sqlite-explorer](.\images\规范文档\sqlite-explorer.png)

1. - 已创建对应于每个实体的表。
   - 表名是基于类名的复数形式。
   - 已将名为 `Id` 的属性推断为自动递增的主键字段。
   - 已创建 `PizzaTopping` 联接表，用于表示披萨和配料之间的多对多关系。
   - EF Core 的主键和外键约束命名约定分别为 `PK_<Primary key property>` 和 `FK_<Dependent entity>_<Principal entity>_<Foreign key property>`。 `<Dependent entity>` 和 `<Principal entity>` 占位符对应于实体类名称。

    备注

   与 ASP.NET Core MVC 一样，EF Core 采用“约定优于配置”理念。 EF Core 约定通过推断开发者的意图来缩短开发时间。 例如，名为 `Id` 或 `<entity name>Id` 的属性被推断为生成的表的主键。 如果选择不采用命名约定，则必须使用 `[Key]` 特性批注属性。

更改模型和更新数据库架构

Contoso Pizza 的经理向你提出了一些新要求，迫使你更改实体模型。 在以下步骤中，你将使用数据注释修改模型。

 提示

你可以使用[预约定模型配置](https://docs.microsoft.com/zh-cn/ef/core/what-is-new/ef-core-6.0/whatsnew#pre-convention-model-configuration)来定义应用于多个属性的规则，而不是数据注释。

1. 在 Models\Pizza.cs 中，进行以下更改：

   1. 为 `System.ComponentModel.DataAnnotations` 添加 `using` 指令。
   2. 在 `Name` 属性之前添加一个 `[Required]` 特性以将属性标记为必需。
   3. 在 `Name` 属性之前添加一个 `[MaxLength(100)]` 特性以指定最大字符串长度 100。

   ```csharp
   using System.ComponentModel.DataAnnotations;
   
   namespace ContosoPizza.Models;
   
   public class Pizza
   {
       public int Id { get; set; }
   
       [Required]
       [MaxLength(100)]
       public string? Name { get; set; }
   
       public Sauce? Sauce { get; set; }
   
       public ICollection<Topping>? Toppings { get; set; }
   }
   ```
   
2. 在 Models\Sauce.cs 中，进行以下更改：

   1. 为 `System.ComponentModel.DataAnnotations` 添加 `using` 指令。
   2. 在 `Name` 属性之前添加一个 `[Required]` 特性以将属性标记为必需。
   3. 在 `Name` 属性之前添加一个 `[MaxLength(100)]` 特性以指定最大字符串长度 100。
   4. 添加名为 `IsVegan` 的 `bool` 属性。

   ```csharp
   using System.ComponentModel.DataAnnotations;
   
   namespace ContosoPizza.Models;
   
   public class Sauce
   {
       public int Id { get; set; }
   
       [Required]
       [MaxLength(100)]
       public string? Name { get; set; }
   
       public bool IsVegan { get; set; }
   }
   ```
   
3. 在 Models\Topping.cs 中，进行以下更改：

   1. 为 `System.ComponentModel.DataAnnotations` 和 `System.Text.Json.Serialization` 添加 `using` 指令。

   2. 在 `Name` 属性之前添加一个 `[Required]` 特性以将属性标记为必需。

   3. 在 `Name` 属性之前添加一个 `[MaxLength(100)]` 特性以指定最大字符串长度 100。

   4. 在 `Name` 属性后直接添加名为 `Calories` 的 `decimal` 属性。

   5. 将 `[JsonIgnore]` 特性添加到 `Pizzas` 属性。

       备注

      这是为了防止 `Topping` 实体在 Web API 代码将响应序列化为 JSON 时包含 `Pizzas` 属性。 如果不这样做，配料的序列化集合将包括使用配料的每个披萨的集合。 该集合中的每个披萨都将包含一个配料集合，每种配料又将包含一个披萨集合。 这种类型的无限循环称为“循环引用”，不能序列化。

   ```csharp
   using System.ComponentModel.DataAnnotations;
   using System.Text.Json.Serialization;
   
   namespace ContosoPizza.Models;
   
   public class Topping
   {
       public int Id { get; set; }
   
       [Required]
       [MaxLength(100)]
       public string? Name { get; set; }
   
       public decimal Calories { get; set; }
   
       [JsonIgnore]
       public ICollection<Pizza>? Pizzas { get; set; }
   }
   ```
   
4. 保存所有更改并生成。

5. 运行以下命令，生成用于创建数据库表的迁移：

   ```dotnetcli
dotnet ef migrations add ModelRevisions --context PizzaContext
   ```
   
   创建名为 *ModelRevisions* 的迁移。

6. 运行以下命令，应用 *ModelRevisions* 迁移：

   ```dotnetcli
   dotnet ef database update --context PizzaContext
   ```
   
7. 在“Sqlite 资源管理器”窗格的标题栏中，选择“刷新数据库”按钮。

![refresh-database](.\images\规范文档\refresh-database.png)

8. 在“Sqlite 资源管理器”窗格中，右键单击 ContosoPizza.db。 选择“显示表 'sqlite_master'”以查看完整的数据库架构和约束。

    重要

   Sqlite 扩展将重新使用开放式 Sqlite 选项卡。

   - 新字段已添加到

     `Toppings` 和`Sauces`。

     - `Calories` 定义为 `TEXT` 列，因为 Sqlite 没有匹配的 `decimal` 类型。
  - 同样，`IsVegan` 定义为 `INTEGER` 列。 Sqlite 没有定义 `bool` 类型。
     - 在这两种情况下，EF Core 管理转换。
     
   - 每个表中的 `Name` 列已标记为 `NOT NULL`，但 Sqlite 没有 `MaxLength` 约束。

* 提示

   	EF Core 数据库提供程序处理将模型架构映射到特定数据库的功能。 虽然 Sqlite 没有为 `MaxLength` 实现相应的约束，但 SQL Server 和 PostgreSQL 等其他数据库实现了。

2. 在“Sqlite 资源管理器”窗格中，右键单击 `_EFMigrationsHistory` 表，然后选择“显示表”。 该表包含应用于数据库的所有迁移的列表。

你已使用迁移来定义和更新数据库架构。 在下一个单元中，你将完成 `PizzaService` 中处理数据的方法。

#### 练习 - 与数据交互

在此单元中，你将编写代码以与数据库进行交互。

#### CRUD 方法

接下来，完成 `PizzaService` 实现。 在 Services\PizzaService.cs 中完成以下步骤：

1. 进行以下更改，如下例所示：

   1. 添加 `using ContosoPizza.Data;` 指令。
   2. 添加 `using Microsoft.EntityFrameworkCore;` 指令。
   3. 在构造函数之前为 `PizzaContext` 添加类级别字段。
   4. 更改构造函数方法签名以接受 `PizzaContext` 参数。
   5. 更改构造函数方法代码，以将参数分配给字段。

   ```csharp
using ContosoPizza.Models;
   using ContosoPizza.Data;
   using Microsoft.EntityFrameworkCore;
   
   namespace ContosoPizza.Services;
   
   public class PizzaService
   {
       private readonly PizzaContext _context;
   
       public PizzaService(PizzaContext context)
       {
           _context = context;
       }
   
       /// ...
       /// CRUD operations removed for brevity
       /// ...
   }
   ```
   
   创建 `PizzaService` 实例时，将注入 `PizzaContext` 作为依赖项。

2. 将 `GetAll` 方法替换为以下代码：

   ```csharp
   public IEnumerable<Pizza> GetAll()
   {
       return _context.Pizzas
           .AsNoTracking()
           .ToList();
   }
   ```
   
   在上述代码中：

   - `Pizzas` 集合包含 pizzas 表中的所有行。
   - `AsNoTracking` 扩展方法指示 EF Core [禁用更改跟踪](https://docs.microsoft.com/zh-cn/ef/core/querying/tracking)。 由于此操作是只读的，因此 `AsNoTracking` 可以优化性能。
   - 所有披萨都随 `ToList` 一起返回。
   
3. 将 `GetById` 方法替换为以下代码：

   ```csharp
   public Pizza? GetById(int id)
   {
       return _context.Pizzas
           .Include(p => p.Toppings)
           .Include(p => p.Sauce)
           .AsNoTracking()
           .SingleOrDefault(p => p.Id == id);
   }
   ```
   
   在上述代码中：

   - `Include` 扩展方法采用 [lambda 表达式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-expressions) 来指定将 `Toppings` 和 `Sauce` 导航属性包含在结果中（[预先加载](https://docs.microsoft.com/zh-cn/ef/core/querying/related-data/eager)）。 如果不这样做，EF Core 将为这些属性返回 null。

   - ```
     SingleOrDefault
     ```
   
      

     方法返回与 lambda 表达式匹配的披萨。

     - 如果没有记录匹配，则返回 `null`。
     - 如果多个记录匹配，则会引发异常。
     - lambda 表达式描述 `Id` 属性等于 `id` 参数的记录。
   
4. 将 `Create` 方法替换为以下代码：

   ```csharp
   public Pizza Create(Pizza newPizza)
   {
       _context.Pizzas.Add(newPizza);
       _context.SaveChanges();
   
       return newPizza;
   }
   ```
   
   在上述代码中：

   - 假定 `newPizza` 为有效对象。 EF Core 不执行数据验证，因此任何验证都必须由 ASP.NET Core 运行时或用户代码处理。
   - `Add` 方法将 `newPizza` 实体添加到 EF Core 的对象图中。
   - `SaveChanges` 方法指示 EF Core 将对象更改保存到数据库。
   
5. 将 `UpdateSauce` 方法替换为以下代码：

   ```csharp
   public void UpdateSauce(int PizzaId, int SauceId)
   {
       var pizzaToUpdate = _context.Pizzas.Find(PizzaId);
       var sauceToUpdate = _context.Sauces.Find(SauceId);
   
       if (pizzaToUpdate is null || sauceToUpdate is null)
       {
           throw new NullReferenceException("Pizza or sauce does not exist");
       }
   
       pizzaToUpdate.Sauce = sauceToUpdate;
   
       _context.SaveChanges();
   }
   ```
   
   在上述代码中：

   - 对现有 `Pizza` 和 `Sauce` 的引用是使用 `Find` 创建的。 `Find` 是按主键查询记录的优化方法。 在查询数据库之前，`Find` 先搜索本地实体图。
   - `Pizza.Sauce` 属性设置为 `Sauce` 对象。
   - `Update` 方法调用是不必要的，因为 EF Core 检测到我们在 `Pizza` 上设置了 `Sauce` 属性。
   - `SaveChanges` 方法指示 EF Core 将对象更改保存到数据库。
   
6. 将 `AddTopping` 方法替换为以下代码：

   ```csharp
   public void AddTopping(int PizzaId, int ToppingId)
   {
       var pizzaToUpdate = _context.Pizzas.Find(PizzaId);
       var toppingToAdd = _context.Toppings.Find(ToppingId);
   
       if (pizzaToUpdate is null || toppingToAdd is null)
       {
           throw new NullReferenceException("Pizza or topping does not exist");
       }
   
       if(pizzaToUpdate.Toppings is null)
       {
           pizzaToUpdate.Toppings = new List<Topping>();
       }
   
       pizzaToUpdate.Toppings.Add(toppingToAdd);
   
       _context.Pizzas.Update(pizzaToUpdate);
       _context.SaveChanges();
   }
   ```
   
   在上述代码中：

   - 对现有 `Pizza` 和 `Topping` 的引用是使用 `Find` 创建的。
   - 将 `Topping` 添加到 `Pizza.Toppings` 集合中。 如果集合不存在，则创建一个新集合。
   - `Update` 方法将 `pizzaToUpdate` 实体标记为在 EF Core 的对象图中已更新。 这种对 `Update` 的显式使用是必需的，因为如果未创建新的 `Pizza.Toppings` 集合，将修改 `Pizza.Toppings` 集合的内容。 EF Core 可以直接自动检测 `Pizza` 上的设置属性，但无法检测到在现有集合上调用了 `Add`。
   - `SaveChanges` 方法指示 EF Core 将对象更改保存到数据库。
   
7. 将 `DeleteById` 方法替换为以下代码：

   ```csharp
   public void DeleteById(int id)
   {
       var pizzaToDelete = _context.Pizzas.Find(id);
       if (pizzaToDelete is not null)
       {
           _context.Pizzas.Remove(pizzaToDelete);
           _context.SaveChanges();
       }        
   }
   ```
   
   在上述代码中：

   - `Find` 方法通过主键（在本例中为 `Id`）检索披萨。
   - `Remove` 方法删除 EF Core 的对象图中的 `pizzaToDelete` 实体。
   - `SaveChanges` 方法指示 EF Core 将对象更改保存到数据库。
   
8. 保存更改。

#### 数据库种子设定

你已经为 `PizzaService` 编写了 CRUD 操作，但如果数据库中有良好的数据，测试“读取”操作会更容易。 让我们修改应用，在启动时设定数据库种子。

 警告

请在分布式环境中谨慎使用此数据库种子设定策略，因为它不会考虑争用条件。

1. 在 Data 文件夹中，添加一个名为 DbInitializer.cs 的新文件。

2. 将以下代码添加到 Data\DbInitializer.cs：

   ```csharp
   using ContosoPizza.Models;
   
   namespace ContosoPizza.Data
   {
       public static class DbInitializer
       {
           public static void Initialize(PizzaContext context)
           {
   
               if (context.Pizzas.Any()
                   && context.Toppings.Any()
                   && context.Sauces.Any())
               {
                   return;   // DB has been seeded
               }
   
               var pepperoniTopping = new Topping { Name = "Pepperoni", Calories = 130 };
               var sausageTopping = new Topping { Name = "Sausage", Calories = 100 };
               var hamTopping = new Topping { Name = "Ham", Calories = 70 };
               var chickenTopping = new Topping { Name = "Chicken", Calories = 50 };
               var pineappleTopping = new Topping { Name = "Pineapple", Calories = 75 };
   
               var tomatoSauce = new Sauce { Name = "Tomato", IsVegan = true };
               var alfredoSauce = new Sauce { Name = "Alfredo", IsVegan = false };
   
               var pizzas = new Pizza[]
               {
                   new Pizza
                       { 
                           Name = "Meat Lovers", 
                           Sauce = tomatoSauce, 
                           Toppings = new List<Topping>
                               {
                                   pepperoniTopping, 
                                   sausageTopping, 
                                   hamTopping, 
                                   chickenTopping
                               }
                       },
                   new Pizza
                       { 
                           Name = "Hawaiian", 
                           Sauce = tomatoSauce, 
                           Toppings = new List<Topping>
                               {
                                   pineappleTopping, 
                                   hamTopping
                               }
                       },
                   new Pizza
                       { 
                           Name="Alfredo Chicken", 
                           Sauce = alfredoSauce, 
                           Toppings = new List<Topping>
                               {
                                   chickenTopping
                               }
                           }
               };
   
               context.Pizzas.AddRange(pizzas);
               context.SaveChanges();
           }
       }
   }
   ```
   
   在上述代码中：

   - `DbInitializer` 类和 `Initialize` 方法都定义为 `static`。
   - `Initialize` 接受 `PizzaContext` 作为参数。
   - 如果三个表中的任何一个都没有记录，则创建 `Pizza`、`Sauce` 和 `Topping` 对象。
   - `Pizza` 对象（及其 `Sauce` 和 `Topping` 导航属性）通过 `AddRange` 添加到对象图中。
   - 对象图更改通过 `SaveChanges` 提交到数据库。
   
3. 在 Data 文件夹中，添加一个名为 Extensions.cs 的新文件。

4. 将以下代码添加到 Data\Extensions.cs：

   ```csharp
namespace ContosoPizza.Data;
   
   public static class Extensions
   {
       public static void CreateDbIfNotExists(this IHost host)
       {
           {
               using (var scope = host.Services.CreateScope())
               {
                   var services = scope.ServiceProvider;
                   var context = services.GetRequiredService<PizzaContext>();
                   if (context.Database.EnsureCreated())
                   {
                       DbInitializer.Initialize(context);
                   }
               }
           }
       }
   }
   ```
   
   在上述代码中：

   - `CreateDbIfNotExists` 方法被定义为 `IHost` 的扩展。

   - 创建对 `PizzaContext` 服务的引用。

   - [EnsureCreated](https://docs.microsoft.com/zh-cn/ef/core/managing-schemas/ensure-created#ensurecreated) 可确保数据库存在。

      重要

     如果不存在数据库，则 `EnsureCreated` 创建一个新数据库。 新数据库未配置为进行迁移，因此请谨慎使用。

   - 调用 `DbIntializer.Initialize` 方法，将 `PizzaContext` 作为参数传递。

5. 同样在 Program.cs 中，将 `// Add the CreateDbIfNotExists method call` 注释替换为以下代码：

   ```csharp
app.CreateDbIfNotExists();
   ```
   
   每当应用运行时，此代码都会调用上一步中定义的扩展方法。

6. 保存所有更改并生成。

你已编写执行基本 CRUD 操作所需的全部代码，并设定数据库在启动时的种子。 在下一个单元中，将在应用中测试这些操作。

### 练习 - 运行应用

在此单元中，将使用 [HttpRepl](https://docs.microsoft.com/zh-cn/aspnet/core/web-api/http-repl/) 工具来测试 API。 API 将使用你的代码与数据库进行交互。

#### 运行应用并连接

1. 从终端运行以下命令：

   ```dotnet-cli
dotnet tool install -g Microsoft.dotnet-httprepl
   ```
   
   此命令安装 HttpRepl 工具。

2. 使用以下命令运行应用：

   ```dotnetcli
dotnet run --urls=https://localhost:5101
   ```
   
   此命令启动应用程序，并将侦听端口指定为 `5101`。

3. 检查运行应用的输出。

   - EF Core 在 SQL 命令执行时将其作为 `info` 日志事件回显。
   - 表和索引是使用 `CREATE` SQL 命令定义的。
   - 在设定数据库种子时执行 `INSERT` 命令。
   - 为了安全，参数值不会回显到控制台。

4. 使用 Sqlite 资源管理器浏览种子数据库。 每个表都有数据。

5. 由于终端被正在运行的应用阻止，请打开另一个终端 (Ctrl+Shift+`) 以测试应用。

6. 在新终端中，运行以下命令:

   ```dotnetcli
   httprepl https://localhost:5101
   ```
   
   HttpRepl 连接到正在运行的 API，并使用 OpenAPI 规范来发现可用的终结点。

#### 测试数据库操作

现在，你已连接了 HttpRepl，接下来让我们试用一下应用。 每次 CRUD 操作后，在 Sqlite 资源管理器中检查数据库以查看发生的更改。

1. 在 HttpRepl 命令提示符下，运行以下命令列出发现的终结点。

   ```dotnetcli
   ls
   ```
   
2. 切换到 `Pizza` 终结点。

   ```dotnetcli
   cd Pizza
   ```
   
3. 运行以下命令，获取所有披萨的列表。

   ```dotnetcli
get
   ```
   
   API 以 JSON 格式返回披萨列表。

    备注

   **为什么 `sauce` 和 `toppings` 属性为 null？** 请记住，在 `PizzaService.GetAll` 方法中，没有使用 `Include` 扩展方法来指定应加载导航属性。

4. 运行以下命令获取单个披萨。

   ```dotnetcli
get 2
   ```
   
   API 返回“夏威夷”披萨。 请注意，已填充 `sauce` 和 `toppings` 属性，因为 `PizzaService.GetById` 方法使用 `Include` 扩展方法。

5. 运行以下命令以添加新的披萨。

   ```dotnetcli
   post
   ```
   
   Visual Studio Code 会打开一个包含临时文件的新选项卡。 该文件包含用于发布新披萨的模板。 粘贴以下 JSON，保存并关闭选项卡。

   ```json
   {
     "name": "BBQ Beef",
     "sauce": {
       "name": "BBQ",
       "isVegan": false
     },
     "toppings": [
       {
         "name": "Smoked Beef Brisket",
         "calories": 250
       }
     ]
   }
   ```
   
6. 运行以下命令，将另一种配料添加到新的烧烤牛肉披萨。

   ```dotnetcli
   put 4/addtopping?toppingId=5 --no-body
   ```
   
7. 运行以下命令，更改烧烤牛肉披萨上的酱汁。

   ```dotnetcli
   put 4/updatesauce?sauceId=2 --no-body
   ```
   
8. 运行以下命令，查看当前烧烤牛肉披萨。

   ```dotnetcli
   get 4
   ```
   
9. 你已意识到，用阿尔弗雷多酱和菠萝制作的烟熏牛腩披萨是个糟糕的主意。 使用以下命令将其删除：

   ```dotnetcli
   delete 4
   ```
   
10. 输入 `exit` 以保留 HttpRepl。

11. 在运行应用的终端中，按 Ctrl+C 停止正在运行的应用。

 提示

可以根据需要试用该应用。 每当想从新数据库开始时，停止应用并删除 ContosoPizza.db、.db-shm 和 .db-wal 文件，然后再次运行该应用。

干得漂亮! 该应用正在按预期使用数据库！ 在下一个单元中，将从现有数据库搭建实体模型基架。

### 练习 - 反向工程

ContosoPizza 的经理要求你添加一个终结点以列出现有数据库中的优惠券。 在本单元中，将从现有数据库创建基架并修改生成的实体类。

#### 检查促销数据库

1. 在“资源管理器”窗格中，右键单击“Promotions/Promotions.db”文件，然后选择“打开数据库”。
2. 在“SQLite 资源管理器”窗格中，展开 Promotions.db 和“优惠券”节点。 请注意数据架构。
3. 右键单击“优惠券”节点，选择“显示表”。 检查优惠券数据。

#### 搭建促销上下文和优惠券模型的基架

1. 运行以下命令：

   ```dotnetcli
   dotnet ef dbcontext scaffold "Data Source=.\Promotions\Promotions.db" Microsoft.EntityFrameworkCore.Sqlite --context-dir .\Data --output-dir .\Models   
   ```
   
   上述命令：

   - 使用提供的连接字符串搭建 `DbContext` 和模型类基架。
   - 指定应使用的 `Microsoft.EntityFrameworkCore.Sqlite` 数据库提供程序。
   - 为生成的 `DbContext` 和模型类指定目录。
   
2. 打开 Models\Coupon.cs。 `Expiration` 属性定义为字符串，因为 Sqlite 没有日期/时间类型。 将 `Expiration` 的类型从 `string?` 更改为 `DateTime`。 EF Core 将管理日期/时间到字符串数据的转换。

   ```csharp
   using System;
   using System.Collections.Generic;
   
   namespace ContosoPizza.Models
   {
       public partial class Coupon
       {
           public long Id { get; set; }
           public string Description { get; set; } = null!;
           public DateTime Expiration { get; set; }
       }
   }
   ```
   
    提示

   如果数据库发生更改，可以生成新的基架文件。 生成的文件每次都会被覆盖，但创建为 `partial` 类时，可以使用自己的单独文件中自定义属性和行为来扩展它们。

#### 添加优惠券终结点

1. 在 Controllers 文件夹中，添加名为 CouponController.cs 的文件，其中包含以下代码：

   ```csharp
   using ContosoPizza.Data;
   using ContosoPizza.Models;
   using Microsoft.AspNetCore.Mvc;
   using Microsoft.EntityFrameworkCore;
   
   namespace ContosoPizza.Controllers;
   
   [ApiController]
   [Route("[controller]")]
   public class CouponController : ControllerBase
   {
       PromotionsContext _context;
   
       public CouponController(PromotionsContext context)
       {
           _context = context;
       }
   
       [HttpGet]
       public IEnumerable<Coupon> Get()
       {
           return _context.Coupons
               .AsNoTracking()
               .ToList();
       }
   }
   ```
   
   在上述代码中：

   - `PromotionsContext` 注入到构造函数中。
   - `Get` 方法返回所有优惠券。
   
2. 同样在 Program.cs 中，将 `// Add the PromotionsContext` 注释替换为以下代码：

   ```csharp
builder.Services.AddSqlite<PromotionsContext>("Data Source=./Promotions/Promotions.db"));
   ```
   
   前面将 `PromotionsContext` 注册到依赖项注入系统。

3. 保存所有更改并运行应用。

   ```dotnetcli
   dotnet run --urls=https://localhost:5101
   ```

#### 测试终结点

1. 在另一个终端中，运行 HttpRepl 命令。

   ```dotnetcli
   httprepl https://localhost:5101
   ```
   
2. 切换到 `Coupon` 终结点。

   ```dotnetcli
   cd Coupon
   ```
   
3. 从数据库中检索优惠券。

   ```dotnetcli
   get
   ```
   
   注意 `expiration` 是日期/时间。

就这么简单！ 你已经从现有数据库创建并修改了基架！



## 8.3 结合使用数据库和最小 API、Entity Framework Core 和 ASP.NET Core

### 学习目标

通过学习本模块，你将能够：

- 了解如何将 Entity Framework Core 添加到最小 API 应用程序。
- 将数据持久保存到内存数据存储。
- 将数据持久保存到 SQLite 数据库。

### 简介

当你生成处理数据的 Web 应用程序时，你很可能希望将该数据存储在数据库中。 幸运的是，基于 ASP.NET Core 生成的最小 API 可以使用 Entity Framework (EF) Core 轻松地与大量数据库集成。

#### 方案：生成原型

你是团队中的一名开发人员。 你已经生成了一个 API，用于处理对数据表的创建、读取、更新和删除 (CRUD) 操作。 你计划生成使用该 API 的前端应用程序。 你需要将数据存储在数据库中，以便可以在前端应用程序中使用数据。

#### 学习内容

你将了解如何使用 EF Core 将数据持久保存到内存数据库，然后再保存到 SQLite。 还将了解如何使用 EF Core 来查询数据库。

#### 主要目标是什么？

向最小 API 应用程序添加数据库支持。

## 什么是 Entity Framework Core？

大多数重要的 Web 应用程序都需要对数据可靠地运行创建、读取、更新和删除 (CRUD) 操作。 它们还需要在应用程序重启期间保留这些更改。 尽管有各种选项可用于在 .NET 应用程序中永久保留数据，但 Entity Framework (EF) Core 是一个用户友好型解决方案，非常适合许多 .NET 应用程序。

### 了解 EF Core

EF Core 是 .NET 应用程序的轻型、可扩展、开源和跨平台的数据访问技术。

EF Core 可以用作对象关系映射器：

- 使 .NET 开发人员能够使用 .NET 对象处理数据库。
- 无需再像通常那样编写大部分数据访问代码。

EF Core 支持大量常见数据库，包括 SQLite、MySQL、PostgreSQL、Oracle 和 Microsoft SQL Server。

### 模型

使用 EF Core 时，数据访问是通过使用模型来执行的。 模型由实体类和表示数据库会话的上下文对象构成。 上下文对象允许查询并保存数据。

### 实体类

在此场景中，你将实现一个比萨饼存储管理 API，因此你将使用 `Pizza` 实体类。 存储中的比萨饼具有名称和说明。 它们还需要 ID，以便 API 和数据库识别它们。 你将在应用程序中使用的 `Pizza` 实体类可识别比萨饼：

```csharp
namespace PizzaStore.Models 
{
  public class Pizza
  {
      public int Id { get; set; }
      public string? Name { get; set; }
      public string? Description { get; set; }
  }
}
```

#### 上下文类

此应用程序只有一个实体类，但大多数应用程序将有多个实体类。 上下文类负责查询数据并将其保存到实体类，以及用于创建和管理数据库连接。

### 使用 EF Core 执行 CRUD 操作

配置 EF Core 后，可以使用它对实体类执行 CRUD 操作。 然后，你可以针对 C# 类进行开发，并将数据库操作委托给上下文类。 数据库提供程序反过来将其转换为特定于数据库的查询语言。 例如，关系数据库的 SQL。 即使上下文中已存在结果中返回的实体，也始终对数据库执行查询。

#### 查询数据

上下文对象公开每个实体类型的集合类。 在前面的示例中，上下文类将 `Pizza` 对象的集合公开为 `Pizzas`。 假设有一个上下文类实例，则可以在数据库中查询所有比萨饼：

```csharp
var pizzas = await db.Pizzas.ToListAsync();
```

#### 插入数据

可以使用相同的上下文对象插入新比萨饼：

```csharp
await db.pizzas.AddAsync(
    new Pizza { ID = 1, Name = "Pepperoni", Description = "The classic pepperoni pizza" });
```

#### 删除数据

删除操作很简单。 它们只需要删除项的 ID：

```csharp
var pizza = await db.pizzas.FindAsync(id);
if (pizza is null)
{
    //Handle error
}
db.pizzas.Remove(pizza);
```

#### 更新数据

同样，你可以更新现有比萨饼：

```csharp
int id = 1;
var updatepizza = new Pizza { Name = "Pineapple", Description = "Ummmm?" })
var pizza = await db.pizzas.FindAsync(id);
if (pizza is null)
{
    //Handle error
}
pizza.Item = updatepizza.Item;
pizza.IsComplete = updatepizza.IsComplete;
await db.SaveChangesAsync();
```

### 使用 EF Core 内存数据库

EF Core 包含可用于测试应用程序的内存数据库提供程序。 内存数据库提供程序对于测试和开发非常有用，但不应在生产中使用。 在接下来的单元中，你将使用内存数据库提供程序来创建数据库并对其执行 CRUD 操作。

## 练习 - 将 EF Core 添加到最小 API

你是公司的开发人员，并且你和你的公司已听说过新的最小 API。 经理要求你为它创建一个项目，这样你就可以讨论一下是否要在下一个项目中使用它。

 备注

本模块使用 .NET CLI（命令行接口）和 Visual Studio Code 进行本地开发。 完成本模块后，你可以使用 Visual Studio (Windows)、Visual Studio for Mac (macOS) 来应用概念，或使用 Visual Studio Code（Windows、Linux & macOS）继续开发。

此模块使用 .NET 6.0 SDK。 通过在首选终端中运行以下命令，确保你已安装 .NET 6.0：

```dotnetcli
dotnet --list-sdks
```

将显示类似于下面的输出：

```console
3.1.100 [C:\program files\dotnet\sdk]
5.0.100 [C:\program files\dotnet\sdk]
6.0.100 [C:\program files\dotnet\sdk]
```

确保列出了以 `6` 开头的版本。 如果未列出任何版本或未找到命令，请[安装最新的 .NET 6.0 SDK](https://dotnet.microsoft.com/download)。

### 设置项目

首先，需要创建一个项目。 你已安装 .NET 6，现已准备就绪。 在本单元中，你会将数据持久性添加到比萨饼管理 API。

1. 通过运行 `dotnet new` 创建 Web API：

   ```bash
   dotnet new web -o PizzaStore -f net6.0
   ```

   你应该会看到 PizzaStore 目录。

2. 输入以下命令，以转到 PizzaStore 目录：

   ```bash
   cd PizzaStore
   ```

3. 安装 Swashbuckle 包：

   ```bash
   dotnet add package Swashbuckle.AspNetCore --version 6.2.3
   ```

4. 创建 Pizza.cs 文件并在其中提供以下内容：

   ```csharp
   namespace PizzaStore.Models 
   {
     public class Pizza
     {
         public int Id { get; set; }
         public string? Name { get; set; }
         public string? Description { get; set; }
     }
   }
   ```

   前面的 `Pizza` 类是一个表示比萨饼的简单对象。 此代码是你的数据模型。 稍后你将使用 Entity Framework (EF) Core 将此数据模型映射到数据库表。

5. 打开 Program.cs，并添加已突出显示的代码：

   ```csharp
   using Microsoft.OpenApi.Models;
   
   var builder = WebApplication.CreateBuilder(args);
   
   builder.Services.AddEndpointsApiExplorer();
   builder.Services.AddSwaggerGen(c =>
   {
        c.SwaggerDoc("v1", new OpenApiInfo {
            Title = "PizzaStore API",
            Description = "Making the Pizzas you love",
            Version = "v1" });
   });
   
   var app = builder.Build();
   app.UseSwagger();
   app.UseSwaggerUI(c =>
   {
      c.SwaggerEndpoint("/swagger/v1/swagger.json", "PizzaStore API V1");
   });
   
   app.MapGet("/", () => "Hello World!");
   
   app.Run();
   ```

   Visual Studio Code 可能会提示你添加资产以调试项目。 单击对话框中的“`Yes`”。

### 将 EF Core 添加到项目

若要将项存储在待办事项列表中，请安装 `EntityFrameworkCore.InMemory` 包。

1. 在终端窗口中，输入以下代码以添加 EF Core InMemory 包：

   ```console
   dotnet add package Microsoft.EntityFrameworkCore.InMemory --version 6.0
   ```

2. 将 `using Microsoft.EntityFrameworkCore;` 添加到 Program.cs 和 Pizza.cs 文件的顶部。

现在，你已将 EF Core 添加到项目，可以将代码连接到要保存和查询的数据。 若要执行此步骤，将创建 `PizzaDb` 类。 `PizzaDb` 类将执行以下任务：

- 从数据库中的 `Pizza` 列表公开你的 `Pizzas` 属性。
- 使用 `UseInMemoryDatabase` 连接内存数据库存储。 只要应用运行时，数据就会存储在此处。

1. 若要设置内存数据库，请将以下代码添加到 `Pizza.cs` 类底部（在最后的 `}` 的上方）：

   ```csharp
   class PizzaDb : DbContext
   {
       public PizzaDb(DbContextOptions options) : base(options) { }
       public DbSet<Pizza> Pizzas { get; set; }
   }
   ```

   `DbContext` 表示一个连接或会话，用于查询和保存数据库中实体的实例。

2. 将 `using PizzaStore.Models;` 添加到 `Program.cs` 文件的顶部。

3. 在 Program.cs 中，调用 `AddSwaggerGen` 之前，添加以下代码：

   ```csharp
   builder.Services.AddDbContext<PizzaDb>(options => options.UseInMemoryDatabase("items"));
   ```

### 返回项列表

1. 若要从比萨饼列表中的项列表中进行读取，请在调用 `app.Run();` 之前添加以下代码以添加“/pizza”路由：

   ```csharp
   app.MapGet("/pizzas", async (PizzaDb db) => await db.Pizzas.ToListAsync());
   ```

### 运行应用程序

1. 通过调用 `dotnet run` 来运行应用。 此操作会生成应用，并将应用托管在 5000-5300 范围内的某个端口上。 HTTPS 会在 7000-7300 范围内为应用选择一个端口。

    备注

   如果要替代随机端口选择行为，可以设置要在 launchSettings.json 中使用的端口。

   ```bash
   dotnet run
   ```

   下面是输出在终端中的情况：

   ```output
   Building...
    info: Microsoft.Hosting.Lifetime[14]
          Now listening on: https://localhost:7200
    info: Microsoft.Hosting.Lifetime[14]
          Now listening on: http://localhost:5100
    info: Microsoft.Hosting.Lifetime[0]
          Application started. Press Ctrl+C to shut down.
    info: Microsoft.Hosting.Lifetime[0]
          Hosting environment: Development
    info: Microsoft.Hosting.Lifetime[0]
          Content root path: /<path>/PizzaStore
   ```

2. 在浏览器中转到 *https://localhost:{PORT}/swagger*。 选择 `GET /pizzas` 按钮，你会看到列表在 `Response body` 下为空。

### 创建新项

让我们将新任务 POST 到你先前创建的 `app.MapGet` 下的比萨饼列表。

```csharp
app.MapPost("/pizza", async (PizzaDb db, Pizza pizza) =>
{
    await db.Pizzas.AddAsync(pizza);
    await db.SaveChangesAsync();
    return Results.Created($"/pizza/{pizza.Id}", pizza);
});
```

### 测试 API

返回到 Swagger，此时应会看到 `POST/pizza`。 向比萨饼列表添加新项：

1. 选择“POST /pizza”。

2. 选择“试用”。

3. 将请求正文替换为以下内容：

   ```json
   {
       "name": "Pepperoni",
       "description": "A classic pepperoni pizza"
   }
   ```

4. 选择“执行”。

### 读取列表中的项

读取列表中的项：

1. 选择“GET /pizzas”。
2. 选择“试用”。
3. 选择“执行”。

`Response body` 将包含刚刚添加的项。

```json
[
  {
    "id": 1,
    "name": "Pepperoni",
    "description": "A classic pepperoni pizza"
  }
]
```

若要根据 `id` GET 项目，请将代码添加到前面创建的 `app.MapPost` 路由下。

```csharp
app.MapGet("/pizza/{id}", async (PizzaDb db, int id) => await db.Pizzas.FindAsync(id));
```

若要查看此内容，可以访问 *https://localhost:{PORT}/pizza/1* 或使用 Swagger UI。 由于使用的是内存数据库，在重启应用程序后不会列出前面创建的比萨饼，因此需要再次输入。

### 更新项

1. 若要更新现有项目，请将代码添加到你创建的 `GET /pizza/{id}` 路由下：

   ```csharp
   app.MapPut("/pizza/{id}", async (PizzaDb db, Pizza updatepizza, int id) =>
   {
       var pizza = await db.Pizzas.FindAsync(id);
       if (pizza is null) return Results.NotFound();
       pizza.Name = updatepizza.Name;
       pizza.Description = updatepizza.Description;
       await db.SaveChangesAsync();
       return Results.NoContent();
   });
   ```

2. 在 Swagger UI 中选择“PUT /pizza/{id}”。

3. 选择“试用”。

4. 在“ID”文本框中，输入 1。

5. 最后，更新 `Request body`。 粘贴以下 JSON 并将 `name` 更改为 `Pineapple`。

   ```json
    {
       "id": 1,
       "name": "Pineapple",
     }
   ```

6. 选择“执行”。

若要测试代码，请滚动回 `GET /pizza/{id}`。 比萨饼现在的名称为 `Pineapple`。

### 删除项

1. 若要更新现有项目，请将代码添加到前面创建的 `PUT /pizza/{id}` 下：

   ```csharp
   app.MapDelete("/pizza/{id}", async (PizzaDb db, int id) =>
   {
     var pizza = await db.Pizzas.FindAsync(id);
     if (pizza is null)
     {
       return Results.NotFound();
     }
     db.Pizzas.Remove(pizza);
     await db.SaveChangesAsync();
     return Results.Ok();
   });
   ```

2. 现在，请尝试使用 Swagger 接口删除某个项。

在本单元中，你将 EF Core 添加到现有的最小 API 应用程序，并使用内存数据库来存储数据。 接下来，你将了解如何使用实际数据库来存储数据，以便在应用程序关闭期间保持数据。

## 将 SQLite 数据库提供程序与 EF Core 结合使用

在前面的单元中，你学习了如何将数据持久保存到内存数据库。 将数据持久保存到内存数据库在开发中非常有用。 但是，由于在应用程序重启时所有数据都将丢失，因此它并不适合用于生产。 在生产环境中，应将数据持久保存到数据库，如 SQL Server、MySQL、PostgreSQL 或 SQLite。

### 数据库提供程序从应用程序代码中抽象化数据库访问

通过抽象层（如 Entity Framework (EF) Core）执行数据库访问的好处之一是，它将应用程序与数据库提供程序分离。 你可以更改数据库提供程序，而无需重写数据库访问代码。 你无法在不影响应用程序代码的情况下切换数据库提供程序，但更改会最小化并本地化。

使用 EF Core 的相关优势在于，你可以重用代码、经验和数据访问库，以便与任何其他 EF Core 数据库提供程序一起使用。

在本教程中，你将使用 [SQLite 数据库](https://www.sqlite.org/index.html)，但也可以使用一个更好的方法。 EF Core 当前支持超过 20 个数据库提供程序。 这些提供程序已在[文档](https://docs.microsoft.com/zh-CN/ef/core/providers/?tabs=dotnet-core-cli%3Fazure-portal%3Dtrue)中列出。

### 添加新数据库提供程序的步骤

通常，你将使用以下步骤来实现新数据库提供程序：

1. 将一个或多个 NuGet 包添加到项目中，以包含数据库提供程序。
2. 配置数据库连接。
3. 在 ASP.NET Core 服务中配置数据库提供程序。
4. 执行数据库迁移。

## 练习 - 将 SQLite 数据库提供程序与 EF Core 结合使用

在此之前，你已将数据保存在内存数据库中。 此数据库在开发应用程序时非常容易设置和使用，但数据不是持久的。 因此，在应用程序重启时数据将丢失。 在部署应用程序之前，需要将数据持久保存到数据库。

在此练习中，你将升级应用程序以使用关系数据库来存储数据。 你将使用 SQLite 来存储数据。

### 设置 SQLite 数据库

完成以下部分以设置 SQLite 数据库。

#### 安装以下工具和包

使用 .NET CLI 和 Visual Studio 包管理器 UI，安装下列包：

- [SQLite EF Core 数据库提供程序](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Sqlite/6.0.0)：可以通过名为[数据库提供程序](https://docs.microsoft.com/zh-CN/ef/core/providers/?tabs=dotnet-core-cli%3Fazure-portal%3Dtrue)的插件库访问许多不同的数据库。 以下包是用于 Entity Framework (EF) Core 的 SQLite 数据库提供程序。

  ```console
  dotnet add package Microsoft.EntityFrameworkCore.Sqlite --version 6.0
  ```

- [EF Core 工具](https://docs.microsoft.com/zh-CN/ef/core/cli/dotnet)：EF Core 工具执行设计时开发任务。 例如，它们基于现有数据库创建迁移、应用迁移和生成模型代码。

  ```console
  dotnet tool install --global dotnet-ef
  ```

- [Microsoft.EntityFrameworkCore.Design](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Design/6.0.0)：包含 EF Core 用于创建数据库的所有设计时逻辑。

  ```console
  dotnet add package Microsoft.EntityFrameworkCore.Design --version 6.0
  ```

### 启用数据库创建

若要启用数据库创建，需要完成两个步骤：

1. 设置数据库连接字符串。
2. 将数据模型迁移到 SQLite 数据库。

### 设置数据库连接字符串

在 Program.cs 的应用生成器 `var builder = WebApplication.CreateBuilder(args);` 下方，添加一个连接字符串。

```csharp
var connectionString = builder.Configuration.GetConnectionString("Pizzas") ?? "Data Source=Pizzas.db";
```

### 将上下文添加到服务

在本教程的 CRUD 部分，你使用的是内存数据库。 现在，要将内存数据库替换为永久性数据库。

将生成服务中的当前内存数据库实现 `builder.Services.AddDbContext<PizzaDb>(options => options.UseInMemoryDatabase("items"));` 替换为此处的 SQLite 数据库：

```csharp
builder.Services.AddSqlite<PizzaDb>(connectionString);
```

### 迁移数据模型

利用 EF Core 迁移工具，你现在可以开始首次迁移 `InitialCreate`。 在终端窗口中，运行 `migrations` 命令：

```console
   dotnet ef migrations add InitialCreate
```

EF Core 将在项目目录中创建一个名为“Migrations”的文件夹，该文件夹包含两个文件，其中包含表示数据库迁移的代码。

### 创建数据库和架构

完成迁移后，可以使用它来创建数据库和架构。

在终端窗口中，运行以下 `database update` 命令，将迁移应用到数据库：

```console
   dotnet ef database update
```

你应在项目目录中看到新创建的 Pizzas.db 文件。

### 运行和测试应用程序

现在，你已经有了一个后备数据库，更改将永久保留。

若要测试应用程序，请在终端窗口中运行 `dotnet run` 命令，并在 Swagger UI 中与 API 交互。 可以使用 Ctrl+C 命令停止运行应用程序。 在 macOS 上使用 Cmd+C。 然后再次运行该应用程序，并验证更改是否仍然保留。







# N、流程图怎么画

| 标志 | 方向                  |
| :--- | :-------------------- |
| TB   | top bottom - 从上到下 |
| BT   | bottom top - 从下到上 |
| RL   | right left - 从右到左 |
| LR   | left right - 从左到右 |
| TD   | 等同于 TB             |

样式的含义：

- 有箭头：一般指数据流方向 -->
- 无箭头：仅表示相关性 --
- 实线：强关联 --
- 虚线：弱关联 -.-

~~~mermaid
graph TB
    1[开始] -.- 2[结束]
~~~
~~~mermaid
graph LR
	1[开始] --> 2[结束]
~~~

~~~mermaid
graph LR
    1[方形] --> 2(圆角) --> 3((圆形)) --> 4>非对称] --> 5{菱形} --> 6{{六角形}}
~~~

~~~mermaid
graph LR
1[\平行四边形\] --> 2[/平行四边形/] --> 3[/梯形\] --> 4[\梯形/]
~~~

~~~mermaid
graph LR
    1[begin] --- 2[end] -- 带文字的无向连接线 --- 3[ooooooo]
~~~

~~~mermaid
graph LR
    1[one] -.- 2[two] -.带文字的虚线.- 3[three] -.带文字和箭头的虚线.-> 4[four]
~~~

~~~mermaid
graph LR
    1[one] === 2[two] == 带文字粗箭头 ==> 3[three]
~~~

~~~mermaid
graph TB
    c1-->a2
    subgraph 第一组
    a1-->a2
    end
    subgraph 第二组
    b1-->b2
    b1-->a2
    end
    subgraph 第三组
    c1-->c2
    end
~~~

