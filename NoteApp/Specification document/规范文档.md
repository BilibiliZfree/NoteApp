*Write by 紫枫伊* **2022年4月27日**

# 一、前言

​	本文档针对`NoteApp`应用建立，主要用于定义应用的外观、应用结构、规范代码命名以及对项目编写过程中遇到的问题及处理方式做阶段性的记录。

# 二、`NoteApp`结构梳理

## 2.1 登录逻辑

### 2.1.1 登录页面布局

~~~mermaid
graph TD
0{{登录界面}} --> 1(登录)
0 --> 2(忘记密码)
0 --> 3(注册)
0 --> 4(设置)
~~~

### 2.1.2 登录逻辑

~~~mermaid
graph TB
0[登录] --> 1[/登录判断/] -- 用户账号密码正确 --- 3[登录成功] --- 主界面
1 -- 用户账号或密码错误 --> 登陆失败提示
~~~

### 2.1.3 忘记密码

~~~mermaid
graph
0(忘记密码) --> 1[找回密码] -- 成功找回 --> 登录页面
1 -- 找不回 --> 7[注册页面]
~~~



### 2.1.4 注册逻辑

~~~mermaid
graph
0[注册页面]
0 --- 1[输入用户名] --- 5[用户名查重]
0 --- 2[输入账号] --- 6[账号查重]
0 --- 3[输入密码] .- 7{密文}
0 --- 4(注册) -- 注册成功 .- 9[登录页面]
~~~



# 三、命名规范

## 1、前缀

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

## 2、中间名

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

## 3、后缀

|  格式   |     说明     |           示例           |
| :-----: | :----------: | :----------------------: |
| `-Dev`  | 表示开发环境 |       `NoteAppDev`       |
|  -View  | 表示视图窗口 | `LoginMainView` 登录主页 |
| -Window |   表示窗体   |    `MainWindow`主窗体    |



# 四、页面布局

## 3.1 登录页面

![登录界面布局 Height="414" Width="540"](.\images\规范文档\QQ图片20220428085133.png)





# 五、项目日记

|     日期      |               操作                |                 备注                 |
| :-----------: | :-------------------------------: | :----------------------------------: |
| 2022年4月27日 |         新建`NoteApp`项目         |      语言框架使用.Net Core 6.0       |
| 2022年4月27日 |           新建规范文档            |  Specification document - 规范文档   |
| 2022年4月27日 |         登录页面逻辑规划          |                                      |
| 2022年4月27日 |    `NoteApp`添加`Views`文件夹     |           用于存放各种界面           |
| 2022年4月28日 |           导入`Prism`包           |       项目组要使用`prism`框架        |
| 2022年4月28日 |  `Views`文件夹中新建`LoginViews`  |       用来存放登录界面各项控件       |
| 2022年4月28日 |      新建`LoginMainView`页面      |              登录主页面              |
| 2022年4月28日 | 配置`App.xaml`和`App.xaml.cs`文件 |      主页指向到`LoginMainView`       |
| 2022年4月28日 |     删除`MainWindow.xaml`文件     |                                      |
| 2022年4月28日 |      导入`MaterialDesign`包       |             用于页面美化             |
| 2022年4月28日 |        配置`App.xaml`文件         | 在全局字典中引用`materialDesign`资源 |
| 2022年4月30日 | 弃用项目，使用`Prism`模板新建项目 |                                      |
| 2022年7月26日 | 登录界面账号密码与ViewModel的绑定 |                已完成                |
| 2022年9月30日 |     初步使用RestSharp访问API      |                                      |



# 六、代码整理

## 5.1 项目结构

~~~mermaid

~~~

## 5.2 代码展示

### 5.2.1 数据表实体类

```c#
 /// <summary>
/// 基础实体类
/// </summary>
public class BaseEntity
{
    /// <summary>
    /// Base Id
    /// </summary>
    [Column(Order = 0)]
    public int Id { get; set; }
    /// <summary>
    /// Base 可用性
    /// </summary>
    [Column(Order = 1)]
    public bool IsEnable { get; set; }
    /// <summary>
    /// Base 创建时间
    /// </summary>
    [Column(Order = 2)]
    public DateTime GreateTime { get; set; }
    /// <summary>
    /// Base 更新时间
    /// </summary>
    [Column(Order = 3)]
    public DateTime UpdateTime { get; set; }
}


[Table("users")]
public class User : BaseEntity
{
    [Required] //非空
    [Column(TypeName = "varchar(100)")]
    [Comment("用户名")] //注释
    public string? UserName { get; set; }
    [Required]
    [Column(TypeName = "varchar(100)")]
    public string? Password { get; set; }
    [Required]
    [MaxLength(11)] // 最大长度
    [Column("手机号码")]
    public string? TelphoneNumber { get; set; }
}
```



## 5.3 Web API

### 5.3.3 结构展示

#### 用户管理

Request URL：https://localhost:7082/api/Users/GetUsers

Response body：

```json
{
  "message": "数据库中有1个用户.1篇文章.",
  "status": true,
  "object": [
    {
      "userName": "string",
      "password": "RzKH+CmNunFjqJeQiVj3wOrnM+JdLgJ5kuou3JvtL6g=",
      "telphone": "string",
      "blogs": [
        {
          "title": "string",
          "context": "string",
          "userEntityID": 1,
          "id": 1,
          "createTime": "2022-09-01T01:31:05.222",
          "updateTime": "2022-09-01T01:31:05.222"
        }
      ],
      "id": 1,
      "createTime": "2022-09-01T01:31:05.222",
      "updateTime": "2022-09-01T01:31:05.222"
    }
  ]
}
```

Response headers：

```json
 content-type: application/json; charset=utf-8 
 date: Fri,30 Sep 2022 08:28:51 GMT 
 server: Kestrel 
```





# 七、问题梳理

|           问题           |                             描述                             |                           处理方法                           |
| :----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| Controller找不到服务接口 | ```System.InvalidOperationException: Unable to resolve service for type 'NoteApp.Api.Services.INoteAppService' while attempting to activate 'NoteApp.Api.Controllers.NoteAppController'.``` | `program`文件中把服务与对应接口绑定<br />```builder.Services.AddTransient<INoteAppService, NoteAppService>();``` |
|                          |                                                              |                                                              |
|                          |                                                              |                                                              |



# 八、知识点归纳

## 8.1 教程：使用 ASP.NET Core 创建最小 Web API

- 项目 2022/05/05 6 个参与者
- 作者：[Rick Anderson](https://twitter.com/RickAndMSFT)

​	构建最小 API，以创建具有最小依赖项的 HTTP API。 它们非常适合于需要在 ASP.NET Core 中仅包括最少文件、功能和依赖项的微服务和应用。

​	本教程介绍使用 ASP.NET Core 生成最小 Web API 的基础知识。 有关基于包含更多功能的[控制器](https://docs.microsoft.com/zh-cn/aspnet/core/web-api/?view=aspnetcore-6.0)创建 Web API 项目的教程，请参阅[创建 Web API](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/first-web-api?view=aspnetcore-6.0)。

### 概述

​	本教程将创建以下 API：

| API                       | 描述                      | 请求正文 | 响应正文       |
| :------------------------ | :------------------------ | :------- | :------------- |
| `GET /`                   | 浏览器测试，“Hello World” | 无       | Hello World!   |
| `GET /todoitems`          | 获取所有待办事项          | None     | 待办事项的数组 |
| `GET /todoitems/complete` | 获取已完成的待办事项      | None     | 待办事项的数组 |
| `GET /todoitems/{id}`     | 按 ID 获取项              | None     | 待办事项       |
| `POST /todoitems`         | 添加新项                  | 待办事项 | 待办事项       |
| `PUT /todoitems/{id}`     | 更新现有项                | 待办事项 | None           |
| `DELETE /todoitems/{id}`  | 删除项                    | 无       | 无             |

### 先决条件

- [Visual Studio](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_1_visual-studio)
- [Visual Studio Code](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_1_visual-studio-code)

- 带有 ASP.NET 和 Web 开发工作负载的 [Visual Studio 2022](https://visualstudio.microsoft.com/vs/#download)。

![image-20220524162358124](.\images\规范文档\image-20220524162358124.png)

### 创建 Web API 项目

- [Visual Studio](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_2_visual-studio)
- [Visual Studio Code](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_2_visual-studio-code)
- 启动 Visual Studio 2022 并选择“创建新项目”。
- 在“创建新项目”对话框中：
  - 在“搜索模板”搜索框中输入 `API`。
  - 选择“ASP.NET Core Web API”模板，然后选择“下一步”。 

![image-20220524162835421](.\images\规范文档\image-20220524162835421.png)

- 将项目命名为 TodoApi，然后选择“下一步”。
- 在“其他信息”对话框中：
  - 选择“.NET 6.0 (长期支持)”
  - 删除“使用控制器(取消选中以使用最小 API)”
  - 选择“创建”

![image-20220524163104955](.\images\规范文档\image-20220524163104955.png)

#### 检查代码

`Program.cs` 文件包含以下代码：

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

var summaries = new[]
{
    "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
};

app.MapGet("/weatherforecast", () =>
{
    var forecast = Enumerable.Range(1, 5).Select(index =>
       new WeatherForecast
       (
           DateTime.Now.AddDays(index),
           Random.Shared.Next(-20, 55),
           summaries[Random.Shared.Next(summaries.Length)]
       ))
        .ToArray();
    return forecast;
})
.WithName("GetWeatherForecast");

app.Run();

internal record WeatherForecast(DateTime Date, int TemperatureC, string? Summary)
{
    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
}
```

项目模板创建了一个支持 [Swagger](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0) 的 `WeatherForecast` API。 Swagger 用于为 Web API 生成有用的文档和帮助页面。

以下突出显示的代码添加了对 Swagger 的支持：

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
```

#### 运行应用

- [Visual Studio](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_3_visual-studio)
- [Visual Studio Code](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_3_visual-studio-code)

按 Ctrl+F5 以在不使用调试程序的情况下运行。

Visual Studio 会显示以下对话框：

![This project is configured to use SSL. To avoid SSL warnings in the browser you can choose to trust the self-signed certificate that IIS Express has generated. Would you like to trust the IIS Express SSL certificate?](https://docs.microsoft.com/zh-cn/aspnet/core/getting-started/_static/trustcertvs22.png?view=aspnetcore-6.0)

如果信任 IIS Express SSL 证书，请选择“是”。

将显示以下对话框：

![Security warning dialog](https://docs.microsoft.com/zh-cn/aspnet/core/getting-started/_static/cert.png?view=aspnetcore-6.0)

如果你同意信任开发证书，请选择“是”。

有关信任 Firefox 浏览器的信息，请参阅 [Firefox SEC_ERROR_INADEQUATE_KEY_USAGE 证书错误](https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-6.0#trust-ff)。

Visual Studio 启动 [Kestrel Web s服务器](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-6.0)。

随即显示 Swagger 页面 `/swagger/index.html`。 选择 **`GET > Try it out> Execute`**。 页面将显示：

- 用于测试 WeatherForecast API 的 [Curl](https://curl.haxx.se/) 命令。
- 用于测试 WeatherForecast API 的 URL。
- 响应代码、正文和标头。
- 包含媒体类型、示例值和架构的下拉列表框。

将请求 URL 复制粘贴到浏览器中：`https://localhost:<port>/WeatherForecast`。 返回类似于以下项的 JSON：

```json
[
  {
    "date": "2021-10-19T14:12:50.3079024-10:00",
    "temperatureC": 13,
    "summary": "Bracing",
    "temperatureF": 55
  },
  {
    "date": "2021-10-20T14:12:50.3080559-10:00",
    "temperatureC": -8,
    "summary": "Bracing",
    "temperatureF": 18
  },
  {
    "date": "2021-10-21T14:12:50.3080601-10:00",
    "temperatureC": 12,
    "summary": "Hot",
    "temperatureF": 53
  },
  {
    "date": "2021-10-22T14:12:50.3080603-10:00",
    "temperatureC": 10,
    "summary": "Sweltering",
    "temperatureF": 49
  },
  {
    "date": "2021-10-23T14:12:50.3080604-10:00",
    "temperatureC": 36,
    "summary": "Warm",
    "temperatureF": 96
  }
]
```

### 更新生成的代码

本教程重点介绍如何创建 Web API，以便删除 Swagger 代码和 `WeatherForecast` 代码。 将 `Program.cs` 文件的内容替换为以下内容：

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

以下突出显示的代码创建具有预配置默认值的 [WebApplicationBuilder](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) 和 [WebApplication](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.builder.webapplication)：

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

以下代码创建返回 `Hello World!` 的 HTTP GET 终结点 `/`：

```csharp
app.MapGet("/", () => "Hello World!");
```

`app.Run();` 运行应用。

从 `Properties/launchSettings.json` 文件中删除两个 `"launchUrl": "swagger",` 行。 如果未指定 `launchUrl`，Web 浏览器将请求 `/` 终结点。

运行应用。 此时将显示 `Hello World!`。 更新后的 `Program.cs` 文件包含一个最小但完整的应用。

### 添加 NuGet 包

必须添加 NuGet 包以支持本教程中使用的数据库和诊断。

- [Visual Studio](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_4_visual-studio)
- [Visual Studio Code](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#tabpanel_4_visual-studio-code)

- 在“工具”菜单中，选择“NuGet 包管理器”>“管理解决方案的 NuGet 包”。
- 在搜索框中输入“Microsoft.EntityFrameworkCore.InMemory”，然后选择 `Microsoft.EntityFrameworkCore.InMemory`。
- 选中右窗格中的“项目”复选框，然后选择“安装” 。
- 按照上述说明添加 `Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore` 包。

### 添加 API 代码

将 `Program.cs` 文件的内容替换为以下代码：

```csharp
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<TodoDb>(opt => opt.UseInMemoryDatabase("TodoList"));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.MapGet("/todoitems", async (TodoDb db) =>
    await db.Todos.ToListAsync());

app.MapGet("/todoitems/complete", async (TodoDb db) =>
    await db.Todos.Where(t => t.IsComplete).ToListAsync());

app.MapGet("/todoitems/{id}", async (int id, TodoDb db) =>
    await db.Todos.FindAsync(id)
        is Todo todo
            ? Results.Ok(todo)
            : Results.NotFound());

app.MapPost("/todoitems", async (Todo todo, TodoDb db) =>
{
    db.Todos.Add(todo);
    await db.SaveChangesAsync();

    return Results.Created($"/todoitems/{todo.Id}", todo);
});

app.MapPut("/todoitems/{id}", async (int id, Todo inputTodo, TodoDb db) =>
{
    var todo = await db.Todos.FindAsync(id);

    if (todo is null) return Results.NotFound();

    todo.Name = inputTodo.Name;
    todo.IsComplete = inputTodo.IsComplete;

    await db.SaveChangesAsync();

    return Results.NoContent();
});

app.MapDelete("/todoitems/{id}", async (int id, TodoDb db) =>
{
    if (await db.Todos.FindAsync(id) is Todo todo)
    {
        db.Todos.Remove(todo);
        await db.SaveChangesAsync();
        return Results.Ok(todo);
    }

    return Results.NotFound();
});

app.Run();

class Todo
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
}

class TodoDb : DbContext
{
    public TodoDb(DbContextOptions<TodoDb> options)
        : base(options) { }

    public DbSet<Todo> Todos => Set<Todo>();
}
```

### 模型和数据库上下文类

示例应用包含以下模型：

```csharp
class Todo
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
}
```

模型是一个表示应用管理的数据的类。 此应用的模型是 `Todo` 类。

示例应用还包含以下数据库上下文类：

```csharp
class TodoDb : DbContext
{
    public TodoDb(DbContextOptions<TodoDb> options)
        : base(options) { }

    public DbSet<Todo> Todos => Set<Todo>();
}
```

数据库上下文是为数据模型协调 [Entity Framework](https://docs.microsoft.com/zh-CN/ef/core/) 功能的主类。 此类由 [Microsoft.EntityFrameworkCore.DbContext](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.entityframeworkcore.dbcontext) 类派生而来。

以下突出显示的代码将数据库上下文添加到[依赖关系注入 (DI)](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-6.0) 容器，并且允许显示与数据库相关的异常：

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<TodoDb>(opt => opt.UseInMemoryDatabase("TodoList"));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();
var app = builder.Build();
```

DI 容器提供对数据库上下文和其他服务的访问权限。

以下代码创建 HTTP POST 终结点 `/todoitems` 以将数据添加到内存中数据库：

```csharp
app.MapPost("/todoitems", async (Todo todo, TodoDb db) =>
{
    db.Todos.Add(todo);
    await db.SaveChangesAsync();

    return Results.Created($"/todoitems/{todo.Id}", todo);
});
```

### 安装 Postman 以测试应用

本教程使用 Postman 测试 Web API。

- 安装 [Postman](https://www.getpostman.com/downloads/)

- 启动 Web 应用。

- 启动 Postman。

- 禁用

  SSL 证书验证

  - 在“文件”>“设置”（“常规”选项卡）中，禁用“SSL 证书验证” 。

     警告

    在测试控制器之后重新启用 SSL 证书验证。



### 测试发布数据

以下说明将数据发布到应用：

- 创建新请求。

- 将 HTTP 方法设置为 `POST`。

- 将 URI 设置为 `https://localhost:<port>/todoitems`。 例如： `https://localhost:5001/todoitems`

- 选择“正文”选项卡。

- 选择“raw”。

- 将类型设置为“JSON”。

- 在请求正文中，输入待办事项的 JSON：

  ```json
  {
    "name":"walk dog",
    "isComplete":true
  }
  ```
  
- 选择**Send**。 ![Postman with Post request details](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api/_static/post2.png?view=aspnetcore-6.0)

### 检查 GET 终结点

示例应用使用对 `MapGet` 的调用实现多个 GET 终结点：

| API                   | 描述                      | 请求正文 | 响应正文       |
| :-------------------- | :------------------------ | :------- | :------------- |
| `GET /`               | 浏览器测试，“Hello World” | 无       | `Hello World!` |
| `GET /todoitems`      | 获取所有待办事项          | None     | 待办事项的数组 |
| `GET /todoitems/{id}` | 按 ID 获取项              | None     | 待办事项       |

```csharp
app.MapGet("/", () => "Hello World!");

app.MapGet("/todoitems", async (TodoDb db) =>
    await db.Todos.ToListAsync());

app.MapGet("/todoitems/complete", async (TodoDb db) =>
    await db.Todos.Where(t => t.IsComplete).ToListAsync());

app.MapGet("/todoitems/{id}", async (int id, TodoDb db) =>
    await db.Todos.FindAsync(id)
        is Todo todo
            ? Results.Ok(todo)
            : Results.NotFound());
```

### 测试 GET 终结点

通过从浏览器或 Postman 调用两个终结点来测试应用。 例如：

- `GET https://localhost:5001/todoitems`
- `GET https://localhost:5001/todoitems/1`

对 `GET /todoitems` 的调用生成如下响应：

```json
[
  {
    "id": 1,
    "name": "Item1",
    "isComplete": false
  }
]
```

#### 使用 Postman 测试 GET 终结点

- 创建新请求。
- 将 HTTP 方法设置为“GET”。
- 将请求 URI 设置为 `https://localhost:<port>/todoitems`。 例如 `https://localhost:5001/todoitems`。
- 选择**Send**。

此应用使用内存中数据库。 如果已重新启动应用，GET 请求不会返回任何数据。 如果未返回任何数据，则首先使用 [POST](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio#post) 将数据发布到应用。

### 返回值

ASP.NET Core 自动将对象序列化为 [JSON](https://www.json.org/)，并将 JSON 写入响应消息的正文中。 此返回类型的响应代码为 [200 OK](https://developer.mozilla.org/docs/Web/HTTP/Status/200)（假设没有未处理的异常）。 未经处理的异常将转换为 5xx 错误。

返回类型可以表示大范围的 HTTP 状态代码。 例如，`GET /todoitems/{id}` 可以返回两个不同的状态值：

- 如果没有任何项与请求的 ID 匹配，该方法将返回 [404 状态](https://developer.mozilla.org/docs/Web/HTTP/Status/404)[NotFound](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.notfound)错误代码。
- 否则，此方法将返回具有 JSON 响应正文的 200。 返回 `item` 则产生 HTTP 200 响应。

### 检查 PUT 终结点

示例应用使用 `MapPut` 实现单个 PUT 终结点：

```csharp
app.MapPut("/todoitems/{id}", async (int id, Todo inputTodo, TodoDb db) =>
{
    var todo = await db.Todos.FindAsync(id);

    if (todo is null) return Results.NotFound();

    todo.Name = inputTodo.Name;
    todo.IsComplete = inputTodo.IsComplete;

    await db.SaveChangesAsync();

    return Results.NoContent();
});
```

此方法类似于 `MapPost` 方法，但它使用 HTTP PUT。 成功响应返回 [204 (无内容)](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)。 根据 HTTP 规范，PUT 请求需要客户端发送整个更新的实体，而不仅仅是更改。 若要支持部分更新，请使用 [HTTP PATCH](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.httppatchattribute)。

#### 测试 PUT 终结点

本示例使用内存内、数据库，每次启动应用时都必须对其进行初始化。 在进行 PUT 调用之前，数据库中必须有一个项。 调用 GET，以确保在调用 PUT 之前数据库中存在项。

更新 ID 为 1 的待办事项并将其名称设置为 `"feed fish"`：

```json
{
  "Id": 1,
  "name": "feed fish",
  "isComplete": false
}
```

### 检查 DELETE 终结点

示例应用使用 `MapDelete` 实现单个 DELETE 终结点：

```csharp
app.MapDelete("/todoitems/{id}", async (int id, TodoDb db) =>
{
    if (await db.Todos.FindAsync(id) is Todo todo)
    {
        db.Todos.Remove(todo);
        await db.SaveChangesAsync();
        return Results.Ok(todo);
    }

    return Results.NotFound();
});
```

使用 Postman 删除待办事项：

- 将方法设置为 `DELETE`。
- 设置要删除的对象的 URI，例如 `https://localhost:5001/todoitems/1`。
- 选择**Send**。



### 防止过度发布

目前，示例应用公开了整个 `Todo` 对象。 生产应用通常使用模型的子集来限制输入和返回的数据。 这背后有多种原因，但安全性是主要原因。 模型的子集通常称为数据传输对象 (DTO)、输入模型或视图模型。 本文使用的是 **DTO**。

DTO 可用于：

- 防止过度发布。
- 隐藏客户端不应查看的属性。
- 省略一些属性以缩减有效负载大小。
- 平展包含嵌套对象的对象图。 对客户端而言，平展的对象图可能更方便。

若要演示 DTO 方法，请更新 `Todo` 类，使其包含机密字段：

```csharp
public class Todo
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
    public string? Secret { get; set; }
}
```

此应用需要隐藏机密字段，但管理应用可以选择公开它。

确保可以发布和获取机密字段。

创建 DTO 模型：

```csharp
public class TodoItemDTO
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }

    public TodoItemDTO() { }
    public TodoItemDTO(Todo todoItem) =>
    (Id, Name, IsComplete) = (todoItem.Id, todoItem.Name, todoItem.IsComplete);
}
```

更新代码以使用 `TodoItemDTO`：

```csharp
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDatabaseDeveloperPageExceptionFilter();
builder.Services.AddDbContext<TodoDb>(opt => opt.UseInMemoryDatabase("TodoList"));
var app = builder.Build();

app.MapGet("/todoitems", async (TodoDb db) =>
    await db.Todos.Select(x => new TodoItemDTO(x)).ToListAsync());

app.MapGet("/todoitems/{id}", async (int id, TodoDb db) =>
    await db.Todos.FindAsync(id)
        is Todo todo
            ? Results.Ok(new TodoItemDTO(todo))
            : Results.NotFound());

app.MapPost("/todoitems", async (TodoItemDTO todoItemDTO, TodoDb db) =>
{
    var todoItem = new Todo
    {
        IsComplete = todoItemDTO.IsComplete,
        Name = todoItemDTO.Name
    };

    db.Todos.Add(todoItem);
    await db.SaveChangesAsync();

    return Results.Created($"/todoitems/{todoItem.Id}", new TodoItemDTO(todoItem));
});

app.MapPut("/todoitems/{id}", async (int id, TodoItemDTO todoItemDTO, TodoDb db) =>
{
    var todo = await db.Todos.FindAsync(id);

    if (todo is null) return Results.NotFound();

    todo.Name = todoItemDTO.Name;
    todo.IsComplete = todoItemDTO.IsComplete;

    await db.SaveChangesAsync();

    return Results.NoContent();
});

app.MapDelete("/todoitems/{id}", async (int id, TodoDb db) =>
{
    if (await db.Todos.FindAsync(id) is Todo todo)
    {
        db.Todos.Remove(todo);
        await db.SaveChangesAsync();
        return Results.Ok(new TodoItemDTO(todo));
    }

    return Results.NotFound();
});

app.Run();

public class Todo
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
    public string? Secret { get; set; }
}

public class TodoItemDTO
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public bool IsComplete { get; set; }

    public TodoItemDTO() { }
    public TodoItemDTO(Todo todoItem) =>
    (Id, Name, IsComplete) = (todoItem.Id, todoItem.Name, todoItem.IsComplete);
}


class TodoDb : DbContext
{
    public TodoDb(DbContextOptions<TodoDb> options)
        : base(options) { }

    public DbSet<Todo> Todos => Set<Todo>();
}
```

确保无法发布或获取机密字段。

### 最小 API 与具有控制器的 API 之间的差异

- 不支持筛选器：例如，不支持 [IAsyncAuthorizationFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncauthorizationfilter)、[IAsyncActionFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncactionfilter)、[IAsyncExceptionFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncexceptionfilter)、[IAsyncResultFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncresultfilter) 和 [IAsyncResourceFilter](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.filters.iasyncresourcefilter)。

- 不支持模型绑定，即`ModelBinderProvider`、`IModelBinder`。 可以使用自定义绑定填充码添加支持。

  - 不支持从窗体进行绑定。 这包括绑定 [IFormFile](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.http.iformfile)。 我们计划在将来添加对 `IFormFile` 的支持。

- 没有对验证的内置支持，即 [IModelValidator](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.mvc.modelbinding.validation.imodelvalidator)

- 不支持[应用程序部件](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/advanced/app-parts?view=aspnetcore-6.0)或[应用程序模型](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/application-model?view=aspnetcore-6.0)。 无法应用或生成自己的约定。

- 没有内置视图呈现支持。 建议使用 [Razor Pages](https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/razor-pages/razor-pages-start?view=aspnetcore-6.0) 呈现视图。

- 不支持 [JsonPatch](https://www.nuget.org/packages/Microsoft.AspNetCore.JsonPatch/)

- 不支持 [OData](https://www.nuget.org/packages/Microsoft.AspNetCore.OData/)

- 不支持 [ApiVersioning](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Versioning/)。 如需更多详细信息，请参阅[此问题](https://github.com/dotnet/aspnet-api-versioning/issues/751)。

### 使用 JsonOptions

以下代码使用 [JsonOptions](https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.http.json.jsonoptions)：

```csharp
using Microsoft.AspNetCore.Http.Json;

var builder = WebApplication.CreateBuilder(args);

// Configure JSON options
builder.Services.Configure<JsonOptions>(options =>
{
    options.SerializerOptions.IncludeFields = true;
});

var app = builder.Build();

app.MapGet("/", () => new Todo { Name = "Walk dog", IsComplete = false });

app.Run();

class Todo
{
    // These are public fields instead of properties.
    public string? Name;
    public bool IsComplete;
}
```

以下代码使用 [JsonSerializerOptions](https://docs.microsoft.com/zh-CN/dotnet/api/system.text.json.jsonserializeroptions)：

```csharp
using System.Text.Json;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var options = new JsonSerializerOptions(JsonSerializerDefaults.Web);

app.MapGet("/", () => Results.Json(new Todo {
                      Name = "Walk dog", IsComplete = false }, options));

app.Run();

class Todo
{
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
}
```

上述代码使用 [Web 默认值](https://docs.microsoft.com/zh-CN/dotnet/standard/serialization/system-text-json-configure-options#web-defaults-for-jsonserializeroptions)，它将属性名称转换为 camel 大小写。

### 测试最小 API

有关测试最小 API 应用的示例，请参阅[此 GitHub 示例](https://github.com/davidfowl/CommunityStandUpMinimalAPI/blob/main/TodoApi.Tests/TodoTests.cs)。

### 发布到 Azure

有关部署到 Azure 的信息，请参阅[快速入门：部署 ASP.NET Web 应用](https://docs.microsoft.com/zh-CN/azure/app-service/quickstart-dotnetcore)。

### 其他资源

- [最小 API 概述](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-6.0)



## 8.2 使用 Entity Framework Core 保留和检索关系数据

### 了解 EF Core

Entity Framework Core 是对象-关系映射程序。 ORM 在代码和数据库中实现域模型之间提供一个层。 EF Core 是一种数据访问 API，允许你使用 .NET POCO（普通旧 CLR 对象）和强类型 LINQ 与数据库进行交互。 这样，你可以花更少的时间与数据库之间转换请求以及编写 SQL，从而让你有更多时间专注于重要的业务逻辑。

使用 EF Core，数据库在 .NET POCO 后面抽象化。 因此，你可以专注于代码，EF Core 处理与基础数据库的直接交互。

使用 EF Core，可以：

- 将数据作为 C# 对象（实体）加载。
- 通过调用这些实体上的方法来添加、修改和删除数据。
- 将多个数据库表映射到单个 C# 实体。
- 处理多个用户同时尝试更新同一记录时出现的并发问题。
- 使用强类型语言集成查询 ([System.Linq](https://docs.microsoft.com/zh-cn/dotnet/api/system.linq)) 语法来查询数据库。
- 访问[多个数据库](https://docs.microsoft.com/zh-cn/ef/core/providers/)，包括 SQL Server、Sqlite、Azure Cosmos DB、PostgreSQL、MySQL 等。
- 从现有数据库生成域模型。
- 根据域模型管理数据库架构。
- 使用单个方法调用提交对相关实体的复杂、深层和/或宽对象图的更改。

### 查看 EF Core 体系结构

下图描述了 EF Core 背后的体系结构。

![ef-core-architecture](.\images\规范文档\ef-core-architecture.png)

[DbContext](https://docs.microsoft.com/zh-cn/ef/core/dbcontext-configuration) 是一个特殊类，它表示工作单元，并提供配置选项、连接字符串、日志记录以及用于将域映射到数据库的模型的方法。 派生自 `DbContext` 的类：

- 表示与数据库之间的活动会话。
- 保存和查询实体的实例。
- 包括 `DbSet<T>` 类型的属性，其表示数据库中的表。

EF Core 提供程序将对象图更改转换为 SQL。

数据库提供程序：

- 是面向特定数据库引擎（例如 SQL Server、Azure Cosmos DB 或 PostgreSQL）的插件库。
- 将方法调用和 LINQ 查询转换为数据库的本机 SQL 方言。
- 扩展 EF Core 以启用数据库引擎特有的功能。

#### 管理数据库架构

EF Core 提供两种主要方法来保持 EF Core 模型和数据库架构同步。至于我们应该选用哪个方法，请确定你是希望以 EF Core 模型为准还是以数据库架构为准。

#### 迁移（以模型为准）

在现实世界的项目中，数据模型会随着应用功能的实现而变化。 随着新实体的添加和删除，需要相应地更改数据库架构。 EF Core 迁移提供了一种增量更新数据库架构的方法，使数据库架构与应用程序的数据模型保持同步，同时保留数据库中的现有数据。

引入数据模型更改时，开发人员使用 EF Core 工具添加相应的迁移。 EF Core 将当前模型与旧模型的快照进行比较以确定差异。 将生成用于实现更改的 C# 代码。 可以针对自定义行为或种子数据修改 C# 文件，并像任何其他源文件一样在项目的源代码管理中进行跟踪。

生成新的迁移后，可通过多种方式将其应用于数据库。 EF Core 将所有应用的迁移记录在一个特殊的历史记录表中。 历史记录表记录了已应用的迁移。

#### 反向工程（以数据库为准）

反向工程是基于数据库架构搭建实体模型类和 `DbContext` 类基架的过程。 此方法通常与 DBA 管理的现有数据库或共享数据库一起使用。

### 练习 - 迁移

在本单元中，将创建将映射到本地 SQLite 数据库中的表的 C# 实体类。 EF 迁移将根据这些实体生成表。 通过迁移，能够以增量方式更新数据库架构。

 备注

本模块使用 [.NET CLI（命令行接口）](https://docs.microsoft.com/zh-cn/dotnet/core/tools/)和 [Visual Studio Code](https://code.visualstudio.com/) 进行本地开发。 完成本模块后，你可以使用 Visual Studio (Windows)、Visual Studio for Mac (macOS) 等开发环境来应用其概念，或使用 Visual Studio Code（Windows、Linux 和 macOS）进行持续开发。

此模块使用 .NET 6.0 SDK。 通过在首选终端中运行以下命令，确保你已安装 .NET 6.0：

```dotnetcli
dotnet --list-sdks
```

将显示类似于下面的输出：

```console
3.1.100 [C:\program files\dotnet\sdk]
5.0.100 [C:\program files\dotnet\sdk]
6.0.100 [C:\program files\dotnet\sdk]
```

确保列出了以 `6` 开头的版本。 如果未列出任何版本或未找到命令，请[安装最新的 .NET 6.0 SDK](https://dotnet.microsoft.com/download)。

### 获取起始代码

1. 从终端运行以下命令，克隆起始代码存储库：

   ```cmd
git clone https://github.com/MicrosoftDocs/mslearn-persist-data-ef-core
   ```
   
   上述命令创建起始代码存储库的本地副本。 该应用管理披萨、配料和酱汁。

2. 切换到克隆的存储库中的 `ContosoPizza` 目录，然后在 Visual Studio Code 中打开它。

   ```cmd
   cd mslearn-persist-data-ef-core\ContosoPizza
   code .
   ```
   
3. 查看代码：

   - 该项目是 ASP.NET Core Web API。
   - Services/PizzaService.cs 是定义 CRUD（创建、读取、更新和删除）方法的服务类。 所有方法当前均引发 `System.NotImplementedException`。
   - 在 Program.cs 中，`PizzaService` 注册到 ASP.NET Core 的依赖项注入系统。
   - Controllers/PizzaController.cs 是一个 `ApiController`，它公开了 HTTP POST、GET、PUT 和 DELETE 谓词的终结点。 这些谓词在 `PizzaService` 上调用相应的 CRUD 方法。 `PizzaService` 注入到 `PizzaController` 的构造函数中。
   - Models 文件夹包含 `PizzaService` 和 `PizzaController` 使用的模型。
   - 实体模型 Pizza.cs、Topping.cs 和 Sauce.cs 具有以下关系：
     - 一个披萨可能有一种或多种配料。
     - 一种配料可用于一个或多个披萨。
     - 一个披萨可能有一种酱汁，但一种酱汁可用于许多披萨。

4. 打开 Visual Studio Code 终端 (Ctrl+`)。 使用以下命令生成应用：

   ```dotnetcli
   dotnet build
   ```
   
   代码应生成，无警告或错误。

### 添加 NuGet 包和 EF Core 工具

在开始之前，需要添加所需的包。

1. 从终端运行以下命令：

   ```dotnetcli
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
   ```
   
   此命令将添加包含 EF Core Sqlite 数据库提供程序及其所有依赖项的 NuGet 包，包括常见的 EF Core 服务。

2. 从终端运行以下命令：

   ```dotnetcli
dotnet add package Microsoft.EntityFrameworkCore.Design
   ```
   
   此命令添加 EF Core 工具所需的包。

3. 从终端运行以下命令：

   ```dotnetcli
   dotnet tool install --global dotnet-ef
   ```
   
   此命令将安装 `dotnet ef`，用于创建迁移和基架的工具。

   * **提示** : 如果已安装 `dotnet ef`，则可以使用 `dotnet tool update --global dotnet-ef` 对其进行更新。

### 绑定模型和 DbContext

现在，你将添加并配置一个 `DbContext` 实现，该实现将用作你将与数据库进行交互的网关。

1. 在项目根目录中，添加一个名为 Data 的新文件夹。

2. 在 Data 目录中，创建一个名为 PizzaContext.cs 的新文件。 将以下代码添加到空文件中：

   ```csharp
   using Microsoft.EntityFrameworkCore;
   using ContosoPizza.Models;
   
   namespace ContosoPizza.Data;
   
   public class PizzaContext : DbContext
   {
       public PizzaContext (DbContextOptions<PizzaContext> options)
           : base(options)
       {
       }
   
       public DbSet<Pizza> Pizzas => Set<Pizza>();
       public DbSet<Topping> Toppings => Set<Topping>();
       public DbSet<Sauce> Sauces => Set<Sauce>();
   }
   ```
   
   在上述代码中：

   - 构造函数接受类型为 `DbContextOptions<PizzaContext>` 的参数。 这允许外部代码传入配置，因此可以在测试和生产代码之间共享相同的 `DbContext`，甚至可以与不同的提供程序一起使用。
   - `DbSet<T>` 属性对应于要在数据库中创建的表。
   - 表名称将匹配 `PizzaContext` 类中的 `DbSet<T>` 属性名称。 如果需要，可以重写此行为。
   - 实例化时，`PizzaContext` 将公开 `Pizzas`、`Toppings` 和 `Sauces` 属性。 对这些属性公开的集合所做的更改将传播到数据库。
   
3. 在 Program.cs 中，将 `// Add the PizzaContext` 替换为以下代码：

   ```csharp
   builder.Services.AddSqlite<PizzaContext>("Data Source=ContosoPizza.db");
   ```
   
   前面的代码：

   - 向 ASP.NET Core 的依赖项注入系统注册 `PizzaContext`。
- 指定 `PizzaContext` 将使用 Sqlite 数据库提供程序。
   - 定义指向本地文件 ContosoPizza.db 的 Sqlite 连接字符串。
   
    备注

   对于使用本地数据库文件的 Sqlite，或许可以像这样对连接字符串进行硬编码。 但是，对于 PostgreSQL 或 SQL Server 等网络数据库，应始终安全地存储连接字符串。 对于本地开发，请使用[机密管理器](https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets)。 对于生产部署，请考虑使用 [Azure Key Vault](https://docs.microsoft.com/zh-cn/aspnet/core/security/key-vault-configuration) 之类的服务。

4. 同样在 Program.cs 中，将 `// Additional using declarations` 替换为以下代码。

   ```csharp
using ContosoPizza.Data;
   ```
   
   前面的代码解决了上一步中的依赖关系。

5. 保存所有更改并生成应用。

### 创建并运行迁移

已经完成了创建迁移所需的所有操作，该迁移用于创建初始数据库。

1. 运行以下命令，生成用于创建数据库表的迁移：

   ```dotnetcli
   dotnet ef migrations add InitialCreate --context PizzaContext
   ```
   
   在上述命令中：

   - 迁移被命名为 *InitialCreate*。
- `--context` 选项指定 *ContosoPizza* 项目中的类的名称，该名称派生自 `DbContext`。
  
   *ContosoPizza* 项目根中显示新的 *Migrations* 目录。 该目录包含 *<timestamp>_InitialCreate.cs* 文件，该文件描述了要转换为数据定义语言 (DDL) 更改脚本的数据库更改。

2. 运行以下命令，应用 *InitialCreate* 迁移：

   ```dotnetcli
   dotnet ef database update --context PizzaContext
   ```
   
   执行上述命令将应用迁移。 由于 ContosoPizza.db 不存在，因此在项目目录中创建它。

    提示

   所有平台均支持 `dotnet ef` 工具。 在 Windows 上的 Visual Studio 中，还可以在集成的“包管理器控制台”窗口中使用 `Add-Migration` 和 `Update-Database` PowerShell cmdlet。

### 检查数据库

EF Core 为应用创建了一个数据库。 让我们看看数据库内部。

1. 在 Visual Studio Code 中，按 Ctrl+Shift+X 打开“扩展”选项卡。
2. 在搜索框中，搜索 `vscode-sqlite`。 显示社区提供的 Sqlite 扩展。
3. 如果需要，安装该扩展。
4. 按 Ctrl+Shift+E 返回到“资源管理器”选项卡。
5. 右键单击 ContosoPizza.db 文件。 选择“打开数据集”。

![open-database](.\images\规范文档\open-database.png)

“SQLite 资源管理器”窗格将在“资源管理器”选项卡上打开。

![sqlite-pane](.\images\规范文档\sqlite-pane.png)

展开“SQLite 资源管理器”窗格及其所有子节点。 右键单击 ContosoPizza.db。 选择“显示表 'sqlite_master'”以查看完整的数据库架构和约束。

![sqlite-explorer](.\images\规范文档\sqlite-explorer.png)

1. - 已创建对应于每个实体的表。
   - 表名是基于类名的复数形式。
   - 已将名为 `Id` 的属性推断为自动递增的主键字段。
   - 已创建 `PizzaTopping` 联接表，用于表示披萨和配料之间的多对多关系。
   - EF Core 的主键和外键约束命名约定分别为 `PK_<Primary key property>` 和 `FK_<Dependent entity>_<Principal entity>_<Foreign key property>`。 `<Dependent entity>` 和 `<Principal entity>` 占位符对应于实体类名称。

    备注

   与 ASP.NET Core MVC 一样，EF Core 采用“约定优于配置”理念。 EF Core 约定通过推断开发者的意图来缩短开发时间。 例如，名为 `Id` 或 `<entity name>Id` 的属性被推断为生成的表的主键。 如果选择不采用命名约定，则必须使用 `[Key]` 特性批注属性。

更改模型和更新数据库架构

Contoso Pizza 的经理向你提出了一些新要求，迫使你更改实体模型。 在以下步骤中，你将使用数据注释修改模型。

 提示

你可以使用[预约定模型配置](https://docs.microsoft.com/zh-cn/ef/core/what-is-new/ef-core-6.0/whatsnew#pre-convention-model-configuration)来定义应用于多个属性的规则，而不是数据注释。

1. 在 Models\Pizza.cs 中，进行以下更改：

   1. 为 `System.ComponentModel.DataAnnotations` 添加 `using` 指令。
   2. 在 `Name` 属性之前添加一个 `[Required]` 特性以将属性标记为必需。
   3. 在 `Name` 属性之前添加一个 `[MaxLength(100)]` 特性以指定最大字符串长度 100。

   ```csharp
   using System.ComponentModel.DataAnnotations;
   
   namespace ContosoPizza.Models;
   
   public class Pizza
   {
       public int Id { get; set; }
   
       [Required]
       [MaxLength(100)]
       public string? Name { get; set; }
   
       public Sauce? Sauce { get; set; }
   
       public ICollection<Topping>? Toppings { get; set; }
   }
   ```
   
2. 在 Models\Sauce.cs 中，进行以下更改：

   1. 为 `System.ComponentModel.DataAnnotations` 添加 `using` 指令。
   2. 在 `Name` 属性之前添加一个 `[Required]` 特性以将属性标记为必需。
   3. 在 `Name` 属性之前添加一个 `[MaxLength(100)]` 特性以指定最大字符串长度 100。
   4. 添加名为 `IsVegan` 的 `bool` 属性。

   ```csharp
   using System.ComponentModel.DataAnnotations;
   
   namespace ContosoPizza.Models;
   
   public class Sauce
   {
       public int Id { get; set; }
   
       [Required]
       [MaxLength(100)]
       public string? Name { get; set; }
   
       public bool IsVegan { get; set; }
   }
   ```
   
3. 在 Models\Topping.cs 中，进行以下更改：

   1. 为 `System.ComponentModel.DataAnnotations` 和 `System.Text.Json.Serialization` 添加 `using` 指令。

   2. 在 `Name` 属性之前添加一个 `[Required]` 特性以将属性标记为必需。

   3. 在 `Name` 属性之前添加一个 `[MaxLength(100)]` 特性以指定最大字符串长度 100。

   4. 在 `Name` 属性后直接添加名为 `Calories` 的 `decimal` 属性。

   5. 将 `[JsonIgnore]` 特性添加到 `Pizzas` 属性。

       备注

      这是为了防止 `Topping` 实体在 Web API 代码将响应序列化为 JSON 时包含 `Pizzas` 属性。 如果不这样做，配料的序列化集合将包括使用配料的每个披萨的集合。 该集合中的每个披萨都将包含一个配料集合，每种配料又将包含一个披萨集合。 这种类型的无限循环称为“循环引用”，不能序列化。

   ```csharp
   using System.ComponentModel.DataAnnotations;
   using System.Text.Json.Serialization;
   
   namespace ContosoPizza.Models;
   
   public class Topping
   {
       public int Id { get; set; }
   
       [Required]
       [MaxLength(100)]
       public string? Name { get; set; }
   
       public decimal Calories { get; set; }
   
       [JsonIgnore]
       public ICollection<Pizza>? Pizzas { get; set; }
   }
   ```
   
4. 保存所有更改并生成。

5. 运行以下命令，生成用于创建数据库表的迁移：

   ```dotnetcli
dotnet ef migrations add ModelRevisions --context PizzaContext
   ```
   
   创建名为 *ModelRevisions* 的迁移。

6. 运行以下命令，应用 *ModelRevisions* 迁移：

   ```dotnetcli
   dotnet ef database update --context PizzaContext
   ```
   
7. 在“Sqlite 资源管理器”窗格的标题栏中，选择“刷新数据库”按钮。

![refresh-database](.\images\规范文档\refresh-database.png)

8. 在“Sqlite 资源管理器”窗格中，右键单击 ContosoPizza.db。 选择“显示表 'sqlite_master'”以查看完整的数据库架构和约束。

    重要

   Sqlite 扩展将重新使用开放式 Sqlite 选项卡。

   - 新字段已添加到

     `Toppings` 和`Sauces`。

     - `Calories` 定义为 `TEXT` 列，因为 Sqlite 没有匹配的 `decimal` 类型。
  - 同样，`IsVegan` 定义为 `INTEGER` 列。 Sqlite 没有定义 `bool` 类型。
     - 在这两种情况下，EF Core 管理转换。
     
   - 每个表中的 `Name` 列已标记为 `NOT NULL`，但 Sqlite 没有 `MaxLength` 约束。

* 提示

   	EF Core 数据库提供程序处理将模型架构映射到特定数据库的功能。 虽然 Sqlite 没有为 `MaxLength` 实现相应的约束，但 SQL Server 和 PostgreSQL 等其他数据库实现了。

2. 在“Sqlite 资源管理器”窗格中，右键单击 `_EFMigrationsHistory` 表，然后选择“显示表”。 该表包含应用于数据库的所有迁移的列表。

你已使用迁移来定义和更新数据库架构。 在下一个单元中，你将完成 `PizzaService` 中处理数据的方法。

#### 练习 - 与数据交互

在此单元中，你将编写代码以与数据库进行交互。

#### CRUD 方法

接下来，完成 `PizzaService` 实现。 在 Services\PizzaService.cs 中完成以下步骤：

1. 进行以下更改，如下例所示：

   1. 添加 `using ContosoPizza.Data;` 指令。
   2. 添加 `using Microsoft.EntityFrameworkCore;` 指令。
   3. 在构造函数之前为 `PizzaContext` 添加类级别字段。
   4. 更改构造函数方法签名以接受 `PizzaContext` 参数。
   5. 更改构造函数方法代码，以将参数分配给字段。

   ```csharp
using ContosoPizza.Models;
   using ContosoPizza.Data;
   using Microsoft.EntityFrameworkCore;
   
   namespace ContosoPizza.Services;
   
   public class PizzaService
   {
       private readonly PizzaContext _context;
   
       public PizzaService(PizzaContext context)
       {
           _context = context;
       }
   
       /// ...
       /// CRUD operations removed for brevity
       /// ...
   }
   ```
   
   创建 `PizzaService` 实例时，将注入 `PizzaContext` 作为依赖项。

2. 将 `GetAll` 方法替换为以下代码：

   ```csharp
   public IEnumerable<Pizza> GetAll()
   {
       return _context.Pizzas
           .AsNoTracking()
           .ToList();
   }
   ```
   
   在上述代码中：

   - `Pizzas` 集合包含 pizzas 表中的所有行。
   - `AsNoTracking` 扩展方法指示 EF Core [禁用更改跟踪](https://docs.microsoft.com/zh-cn/ef/core/querying/tracking)。 由于此操作是只读的，因此 `AsNoTracking` 可以优化性能。
   - 所有披萨都随 `ToList` 一起返回。
   
3. 将 `GetById` 方法替换为以下代码：

   ```csharp
   public Pizza? GetById(int id)
   {
       return _context.Pizzas
           .Include(p => p.Toppings)
           .Include(p => p.Sauce)
           .AsNoTracking()
           .SingleOrDefault(p => p.Id == id);
   }
   ```
   
   在上述代码中：

   - `Include` 扩展方法采用 [lambda 表达式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-expressions) 来指定将 `Toppings` 和 `Sauce` 导航属性包含在结果中（[预先加载](https://docs.microsoft.com/zh-cn/ef/core/querying/related-data/eager)）。 如果不这样做，EF Core 将为这些属性返回 null。

   - ```
     SingleOrDefault
     ```
   
      

     方法返回与 lambda 表达式匹配的披萨。

     - 如果没有记录匹配，则返回 `null`。
     - 如果多个记录匹配，则会引发异常。
     - lambda 表达式描述 `Id` 属性等于 `id` 参数的记录。
   
4. 将 `Create` 方法替换为以下代码：

   ```csharp
   public Pizza Create(Pizza newPizza)
   {
       _context.Pizzas.Add(newPizza);
       _context.SaveChanges();
   
       return newPizza;
   }
   ```
   
   在上述代码中：

   - 假定 `newPizza` 为有效对象。 EF Core 不执行数据验证，因此任何验证都必须由 ASP.NET Core 运行时或用户代码处理。
   - `Add` 方法将 `newPizza` 实体添加到 EF Core 的对象图中。
   - `SaveChanges` 方法指示 EF Core 将对象更改保存到数据库。
   
5. 将 `UpdateSauce` 方法替换为以下代码：

   ```csharp
   public void UpdateSauce(int PizzaId, int SauceId)
   {
       var pizzaToUpdate = _context.Pizzas.Find(PizzaId);
       var sauceToUpdate = _context.Sauces.Find(SauceId);
   
       if (pizzaToUpdate is null || sauceToUpdate is null)
       {
           throw new NullReferenceException("Pizza or sauce does not exist");
       }
   
       pizzaToUpdate.Sauce = sauceToUpdate;
   
       _context.SaveChanges();
   }
   ```
   
   在上述代码中：

   - 对现有 `Pizza` 和 `Sauce` 的引用是使用 `Find` 创建的。 `Find` 是按主键查询记录的优化方法。 在查询数据库之前，`Find` 先搜索本地实体图。
   - `Pizza.Sauce` 属性设置为 `Sauce` 对象。
   - `Update` 方法调用是不必要的，因为 EF Core 检测到我们在 `Pizza` 上设置了 `Sauce` 属性。
   - `SaveChanges` 方法指示 EF Core 将对象更改保存到数据库。
   
6. 将 `AddTopping` 方法替换为以下代码：

   ```csharp
   public void AddTopping(int PizzaId, int ToppingId)
   {
       var pizzaToUpdate = _context.Pizzas.Find(PizzaId);
       var toppingToAdd = _context.Toppings.Find(ToppingId);
   
       if (pizzaToUpdate is null || toppingToAdd is null)
       {
           throw new NullReferenceException("Pizza or topping does not exist");
       }
   
       if(pizzaToUpdate.Toppings is null)
       {
           pizzaToUpdate.Toppings = new List<Topping>();
       }
   
       pizzaToUpdate.Toppings.Add(toppingToAdd);
   
       _context.Pizzas.Update(pizzaToUpdate);
       _context.SaveChanges();
   }
   ```
   
   在上述代码中：

   - 对现有 `Pizza` 和 `Topping` 的引用是使用 `Find` 创建的。
   - 将 `Topping` 添加到 `Pizza.Toppings` 集合中。 如果集合不存在，则创建一个新集合。
   - `Update` 方法将 `pizzaToUpdate` 实体标记为在 EF Core 的对象图中已更新。 这种对 `Update` 的显式使用是必需的，因为如果未创建新的 `Pizza.Toppings` 集合，将修改 `Pizza.Toppings` 集合的内容。 EF Core 可以直接自动检测 `Pizza` 上的设置属性，但无法检测到在现有集合上调用了 `Add`。
   - `SaveChanges` 方法指示 EF Core 将对象更改保存到数据库。
   
7. 将 `DeleteById` 方法替换为以下代码：

   ```csharp
   public void DeleteById(int id)
   {
       var pizzaToDelete = _context.Pizzas.Find(id);
       if (pizzaToDelete is not null)
       {
           _context.Pizzas.Remove(pizzaToDelete);
           _context.SaveChanges();
       }        
   }
   ```
   
   在上述代码中：

   - `Find` 方法通过主键（在本例中为 `Id`）检索披萨。
   - `Remove` 方法删除 EF Core 的对象图中的 `pizzaToDelete` 实体。
   - `SaveChanges` 方法指示 EF Core 将对象更改保存到数据库。
   
8. 保存更改。

#### 数据库种子设定

你已经为 `PizzaService` 编写了 CRUD 操作，但如果数据库中有良好的数据，测试“读取”操作会更容易。 让我们修改应用，在启动时设定数据库种子。

 警告

请在分布式环境中谨慎使用此数据库种子设定策略，因为它不会考虑争用条件。

1. 在 Data 文件夹中，添加一个名为 DbInitializer.cs 的新文件。

2. 将以下代码添加到 Data\DbInitializer.cs：

   ```csharp
   using ContosoPizza.Models;
   
   namespace ContosoPizza.Data
   {
       public static class DbInitializer
       {
           public static void Initialize(PizzaContext context)
           {
   
               if (context.Pizzas.Any()
                   && context.Toppings.Any()
                   && context.Sauces.Any())
               {
                   return;   // DB has been seeded
               }
   
               var pepperoniTopping = new Topping { Name = "Pepperoni", Calories = 130 };
               var sausageTopping = new Topping { Name = "Sausage", Calories = 100 };
               var hamTopping = new Topping { Name = "Ham", Calories = 70 };
               var chickenTopping = new Topping { Name = "Chicken", Calories = 50 };
               var pineappleTopping = new Topping { Name = "Pineapple", Calories = 75 };
   
               var tomatoSauce = new Sauce { Name = "Tomato", IsVegan = true };
               var alfredoSauce = new Sauce { Name = "Alfredo", IsVegan = false };
   
               var pizzas = new Pizza[]
               {
                   new Pizza
                       { 
                           Name = "Meat Lovers", 
                           Sauce = tomatoSauce, 
                           Toppings = new List<Topping>
                               {
                                   pepperoniTopping, 
                                   sausageTopping, 
                                   hamTopping, 
                                   chickenTopping
                               }
                       },
                   new Pizza
                       { 
                           Name = "Hawaiian", 
                           Sauce = tomatoSauce, 
                           Toppings = new List<Topping>
                               {
                                   pineappleTopping, 
                                   hamTopping
                               }
                       },
                   new Pizza
                       { 
                           Name="Alfredo Chicken", 
                           Sauce = alfredoSauce, 
                           Toppings = new List<Topping>
                               {
                                   chickenTopping
                               }
                           }
               };
   
               context.Pizzas.AddRange(pizzas);
               context.SaveChanges();
           }
       }
   }
   ```
   
   在上述代码中：

   - `DbInitializer` 类和 `Initialize` 方法都定义为 `static`。
   - `Initialize` 接受 `PizzaContext` 作为参数。
   - 如果三个表中的任何一个都没有记录，则创建 `Pizza`、`Sauce` 和 `Topping` 对象。
   - `Pizza` 对象（及其 `Sauce` 和 `Topping` 导航属性）通过 `AddRange` 添加到对象图中。
   - 对象图更改通过 `SaveChanges` 提交到数据库。
   
3. 在 Data 文件夹中，添加一个名为 Extensions.cs 的新文件。

4. 将以下代码添加到 Data\Extensions.cs：

   ```csharp
namespace ContosoPizza.Data;
   
   public static class Extensions
   {
       public static void CreateDbIfNotExists(this IHost host)
       {
           {
               using (var scope = host.Services.CreateScope())
               {
                   var services = scope.ServiceProvider;
                   var context = services.GetRequiredService<PizzaContext>();
                   if (context.Database.EnsureCreated())
                   {
                       DbInitializer.Initialize(context);
                   }
               }
           }
       }
   }
   ```
   
   在上述代码中：

   - `CreateDbIfNotExists` 方法被定义为 `IHost` 的扩展。

   - 创建对 `PizzaContext` 服务的引用。

   - [EnsureCreated](https://docs.microsoft.com/zh-cn/ef/core/managing-schemas/ensure-created#ensurecreated) 可确保数据库存在。

      重要

     如果不存在数据库，则 `EnsureCreated` 创建一个新数据库。 新数据库未配置为进行迁移，因此请谨慎使用。

   - 调用 `DbIntializer.Initialize` 方法，将 `PizzaContext` 作为参数传递。

5. 同样在 Program.cs 中，将 `// Add the CreateDbIfNotExists method call` 注释替换为以下代码：

   ```csharp
app.CreateDbIfNotExists();
   ```
   
   每当应用运行时，此代码都会调用上一步中定义的扩展方法。

6. 保存所有更改并生成。

你已编写执行基本 CRUD 操作所需的全部代码，并设定数据库在启动时的种子。 在下一个单元中，将在应用中测试这些操作。

### 练习 - 运行应用

在此单元中，将使用 [HttpRepl](https://docs.microsoft.com/zh-cn/aspnet/core/web-api/http-repl/) 工具来测试 API。 API 将使用你的代码与数据库进行交互。

#### 运行应用并连接

1. 从终端运行以下命令：

   ```dotnet-cli
dotnet tool install -g Microsoft.dotnet-httprepl
   ```
   
   此命令安装 HttpRepl 工具。

2. 使用以下命令运行应用：

   ```dotnetcli
dotnet run --urls=https://localhost:5101
   ```
   
   此命令启动应用程序，并将侦听端口指定为 `5101`。

3. 检查运行应用的输出。

   - EF Core 在 SQL 命令执行时将其作为 `info` 日志事件回显。
   - 表和索引是使用 `CREATE` SQL 命令定义的。
   - 在设定数据库种子时执行 `INSERT` 命令。
   - 为了安全，参数值不会回显到控制台。

4. 使用 Sqlite 资源管理器浏览种子数据库。 每个表都有数据。

5. 由于终端被正在运行的应用阻止，请打开另一个终端 (Ctrl+Shift+`) 以测试应用。

6. 在新终端中，运行以下命令:

   ```dotnetcli
   httprepl https://localhost:5101
   ```
   
   HttpRepl 连接到正在运行的 API，并使用 OpenAPI 规范来发现可用的终结点。

#### 测试数据库操作

现在，你已连接了 HttpRepl，接下来让我们试用一下应用。 每次 CRUD 操作后，在 Sqlite 资源管理器中检查数据库以查看发生的更改。

1. 在 HttpRepl 命令提示符下，运行以下命令列出发现的终结点。

   ```dotnetcli
   ls
   ```
   
2. 切换到 `Pizza` 终结点。

   ```dotnetcli
   cd Pizza
   ```
   
3. 运行以下命令，获取所有披萨的列表。

   ```dotnetcli
get
   ```
   
   API 以 JSON 格式返回披萨列表。

    备注

   **为什么 `sauce` 和 `toppings` 属性为 null？** 请记住，在 `PizzaService.GetAll` 方法中，没有使用 `Include` 扩展方法来指定应加载导航属性。

4. 运行以下命令获取单个披萨。

   ```dotnetcli
get 2
   ```
   
   API 返回“夏威夷”披萨。 请注意，已填充 `sauce` 和 `toppings` 属性，因为 `PizzaService.GetById` 方法使用 `Include` 扩展方法。

5. 运行以下命令以添加新的披萨。

   ```dotnetcli
   post
   ```
   
   Visual Studio Code 会打开一个包含临时文件的新选项卡。 该文件包含用于发布新披萨的模板。 粘贴以下 JSON，保存并关闭选项卡。

   ```json
   {
     "name": "BBQ Beef",
     "sauce": {
       "name": "BBQ",
       "isVegan": false
     },
     "toppings": [
       {
         "name": "Smoked Beef Brisket",
         "calories": 250
       }
     ]
   }
   ```
   
6. 运行以下命令，将另一种配料添加到新的烧烤牛肉披萨。

   ```dotnetcli
   put 4/addtopping?toppingId=5 --no-body
   ```
   
7. 运行以下命令，更改烧烤牛肉披萨上的酱汁。

   ```dotnetcli
   put 4/updatesauce?sauceId=2 --no-body
   ```
   
8. 运行以下命令，查看当前烧烤牛肉披萨。

   ```dotnetcli
   get 4
   ```
   
9. 你已意识到，用阿尔弗雷多酱和菠萝制作的烟熏牛腩披萨是个糟糕的主意。 使用以下命令将其删除：

   ```dotnetcli
   delete 4
   ```
   
10. 输入 `exit` 以保留 HttpRepl。

11. 在运行应用的终端中，按 Ctrl+C 停止正在运行的应用。

 提示

可以根据需要试用该应用。 每当想从新数据库开始时，停止应用并删除 ContosoPizza.db、.db-shm 和 .db-wal 文件，然后再次运行该应用。

干得漂亮! 该应用正在按预期使用数据库！ 在下一个单元中，将从现有数据库搭建实体模型基架。

### 练习 - 反向工程

ContosoPizza 的经理要求你添加一个终结点以列出现有数据库中的优惠券。 在本单元中，将从现有数据库创建基架并修改生成的实体类。

#### 检查促销数据库

1. 在“资源管理器”窗格中，右键单击“Promotions/Promotions.db”文件，然后选择“打开数据库”。
2. 在“SQLite 资源管理器”窗格中，展开 Promotions.db 和“优惠券”节点。 请注意数据架构。
3. 右键单击“优惠券”节点，选择“显示表”。 检查优惠券数据。

#### 搭建促销上下文和优惠券模型的基架

1. 运行以下命令：

   ```dotnetcli
   dotnet ef dbcontext scaffold "Data Source=.\Promotions\Promotions.db" Microsoft.EntityFrameworkCore.Sqlite --context-dir .\Data --output-dir .\Models   
   ```
   
   上述命令：

   - 使用提供的连接字符串搭建 `DbContext` 和模型类基架。
   - 指定应使用的 `Microsoft.EntityFrameworkCore.Sqlite` 数据库提供程序。
   - 为生成的 `DbContext` 和模型类指定目录。
   
2. 打开 Models\Coupon.cs。 `Expiration` 属性定义为字符串，因为 Sqlite 没有日期/时间类型。 将 `Expiration` 的类型从 `string?` 更改为 `DateTime`。 EF Core 将管理日期/时间到字符串数据的转换。

   ```csharp
   using System;
   using System.Collections.Generic;
   
   namespace ContosoPizza.Models
   {
       public partial class Coupon
       {
           public long Id { get; set; }
           public string Description { get; set; } = null!;
           public DateTime Expiration { get; set; }
       }
   }
   ```
   
    提示

   如果数据库发生更改，可以生成新的基架文件。 生成的文件每次都会被覆盖，但创建为 `partial` 类时，可以使用自己的单独文件中自定义属性和行为来扩展它们。

#### 添加优惠券终结点

1. 在 Controllers 文件夹中，添加名为 CouponController.cs 的文件，其中包含以下代码：

   ```csharp
   using ContosoPizza.Data;
   using ContosoPizza.Models;
   using Microsoft.AspNetCore.Mvc;
   using Microsoft.EntityFrameworkCore;
   
   namespace ContosoPizza.Controllers;
   
   [ApiController]
   [Route("[controller]")]
   public class CouponController : ControllerBase
   {
       PromotionsContext _context;
   
       public CouponController(PromotionsContext context)
       {
           _context = context;
       }
   
       [HttpGet]
       public IEnumerable<Coupon> Get()
       {
           return _context.Coupons
               .AsNoTracking()
               .ToList();
       }
   }
   ```
   
   在上述代码中：

   - `PromotionsContext` 注入到构造函数中。
   - `Get` 方法返回所有优惠券。
   
2. 同样在 Program.cs 中，将 `// Add the PromotionsContext` 注释替换为以下代码：

   ```csharp
builder.Services.AddSqlite<PromotionsContext>("Data Source=./Promotions/Promotions.db"));
   ```
   
   前面将 `PromotionsContext` 注册到依赖项注入系统。

3. 保存所有更改并运行应用。

   ```dotnetcli
   dotnet run --urls=https://localhost:5101
   ```

#### 测试终结点

1. 在另一个终端中，运行 HttpRepl 命令。

   ```dotnetcli
   httprepl https://localhost:5101
   ```
   
2. 切换到 `Coupon` 终结点。

   ```dotnetcli
   cd Coupon
   ```
   
3. 从数据库中检索优惠券。

   ```dotnetcli
   get
   ```
   
   注意 `expiration` 是日期/时间。

就这么简单！ 你已经从现有数据库创建并修改了基架！



## 8.3 结合使用数据库和最小 API、Entity Framework Core 和 ASP.NET Core

### 学习目标

通过学习本模块，你将能够：

- 了解如何将 Entity Framework Core 添加到最小 API 应用程序。
- 将数据持久保存到内存数据存储。
- 将数据持久保存到 SQLite 数据库。

### 简介

当你生成处理数据的 Web 应用程序时，你很可能希望将该数据存储在数据库中。 幸运的是，基于 ASP.NET Core 生成的最小 API 可以使用 Entity Framework (EF) Core 轻松地与大量数据库集成。

#### 方案：生成原型

你是团队中的一名开发人员。 你已经生成了一个 API，用于处理对数据表的创建、读取、更新和删除 (CRUD) 操作。 你计划生成使用该 API 的前端应用程序。 你需要将数据存储在数据库中，以便可以在前端应用程序中使用数据。

#### 学习内容

你将了解如何使用 EF Core 将数据持久保存到内存数据库，然后再保存到 SQLite。 还将了解如何使用 EF Core 来查询数据库。

#### 主要目标是什么？

向最小 API 应用程序添加数据库支持。

## 什么是 Entity Framework Core？

大多数重要的 Web 应用程序都需要对数据可靠地运行创建、读取、更新和删除 (CRUD) 操作。 它们还需要在应用程序重启期间保留这些更改。 尽管有各种选项可用于在 .NET 应用程序中永久保留数据，但 Entity Framework (EF) Core 是一个用户友好型解决方案，非常适合许多 .NET 应用程序。

### 了解 EF Core

EF Core 是 .NET 应用程序的轻型、可扩展、开源和跨平台的数据访问技术。

EF Core 可以用作对象关系映射器：

- 使 .NET 开发人员能够使用 .NET 对象处理数据库。
- 无需再像通常那样编写大部分数据访问代码。

EF Core 支持大量常见数据库，包括 SQLite、MySQL、PostgreSQL、Oracle 和 Microsoft SQL Server。

### 模型

使用 EF Core 时，数据访问是通过使用模型来执行的。 模型由实体类和表示数据库会话的上下文对象构成。 上下文对象允许查询并保存数据。

### 实体类

在此场景中，你将实现一个比萨饼存储管理 API，因此你将使用 `Pizza` 实体类。 存储中的比萨饼具有名称和说明。 它们还需要 ID，以便 API 和数据库识别它们。 你将在应用程序中使用的 `Pizza` 实体类可识别比萨饼：

```csharp
namespace PizzaStore.Models 
{
  public class Pizza
  {
      public int Id { get; set; }
      public string? Name { get; set; }
      public string? Description { get; set; }
  }
}
```

#### 上下文类

此应用程序只有一个实体类，但大多数应用程序将有多个实体类。 上下文类负责查询数据并将其保存到实体类，以及用于创建和管理数据库连接。

### 使用 EF Core 执行 CRUD 操作

配置 EF Core 后，可以使用它对实体类执行 CRUD 操作。 然后，你可以针对 C# 类进行开发，并将数据库操作委托给上下文类。 数据库提供程序反过来将其转换为特定于数据库的查询语言。 例如，关系数据库的 SQL。 即使上下文中已存在结果中返回的实体，也始终对数据库执行查询。

#### 查询数据

上下文对象公开每个实体类型的集合类。 在前面的示例中，上下文类将 `Pizza` 对象的集合公开为 `Pizzas`。 假设有一个上下文类实例，则可以在数据库中查询所有比萨饼：

```csharp
var pizzas = await db.Pizzas.ToListAsync();
```

#### 插入数据

可以使用相同的上下文对象插入新比萨饼：

```csharp
await db.pizzas.AddAsync(
    new Pizza { ID = 1, Name = "Pepperoni", Description = "The classic pepperoni pizza" });
```

#### 删除数据

删除操作很简单。 它们只需要删除项的 ID：

```csharp
var pizza = await db.pizzas.FindAsync(id);
if (pizza is null)
{
    //Handle error
}
db.pizzas.Remove(pizza);
```

#### 更新数据

同样，你可以更新现有比萨饼：

```csharp
int id = 1;
var updatepizza = new Pizza { Name = "Pineapple", Description = "Ummmm?" })
var pizza = await db.pizzas.FindAsync(id);
if (pizza is null)
{
    //Handle error
}
pizza.Item = updatepizza.Item;
pizza.IsComplete = updatepizza.IsComplete;
await db.SaveChangesAsync();
```

### 使用 EF Core 内存数据库

EF Core 包含可用于测试应用程序的内存数据库提供程序。 内存数据库提供程序对于测试和开发非常有用，但不应在生产中使用。 在接下来的单元中，你将使用内存数据库提供程序来创建数据库并对其执行 CRUD 操作。

## 练习 - 将 EF Core 添加到最小 API

你是公司的开发人员，并且你和你的公司已听说过新的最小 API。 经理要求你为它创建一个项目，这样你就可以讨论一下是否要在下一个项目中使用它。

 备注

本模块使用 .NET CLI（命令行接口）和 Visual Studio Code 进行本地开发。 完成本模块后，你可以使用 Visual Studio (Windows)、Visual Studio for Mac (macOS) 来应用概念，或使用 Visual Studio Code（Windows、Linux & macOS）继续开发。

此模块使用 .NET 6.0 SDK。 通过在首选终端中运行以下命令，确保你已安装 .NET 6.0：

```dotnetcli
dotnet --list-sdks
```

将显示类似于下面的输出：

```console
3.1.100 [C:\program files\dotnet\sdk]
5.0.100 [C:\program files\dotnet\sdk]
6.0.100 [C:\program files\dotnet\sdk]
```

确保列出了以 `6` 开头的版本。 如果未列出任何版本或未找到命令，请[安装最新的 .NET 6.0 SDK](https://dotnet.microsoft.com/download)。

### 设置项目

首先，需要创建一个项目。 你已安装 .NET 6，现已准备就绪。 在本单元中，你会将数据持久性添加到比萨饼管理 API。

1. 通过运行 `dotnet new` 创建 Web API：

   ```bash
   dotnet new web -o PizzaStore -f net6.0
   ```

   你应该会看到 PizzaStore 目录。

2. 输入以下命令，以转到 PizzaStore 目录：

   ```bash
   cd PizzaStore
   ```

3. 安装 Swashbuckle 包：

   ```bash
   dotnet add package Swashbuckle.AspNetCore --version 6.2.3
   ```

4. 创建 Pizza.cs 文件并在其中提供以下内容：

   ```csharp
   namespace PizzaStore.Models 
   {
     public class Pizza
     {
         public int Id { get; set; }
         public string? Name { get; set; }
         public string? Description { get; set; }
     }
   }
   ```

   前面的 `Pizza` 类是一个表示比萨饼的简单对象。 此代码是你的数据模型。 稍后你将使用 Entity Framework (EF) Core 将此数据模型映射到数据库表。

5. 打开 Program.cs，并添加已突出显示的代码：

   ```csharp
   using Microsoft.OpenApi.Models;
   
   var builder = WebApplication.CreateBuilder(args);
   
   builder.Services.AddEndpointsApiExplorer();
   builder.Services.AddSwaggerGen(c =>
   {
        c.SwaggerDoc("v1", new OpenApiInfo {
            Title = "PizzaStore API",
            Description = "Making the Pizzas you love",
            Version = "v1" });
   });
   
   var app = builder.Build();
   app.UseSwagger();
   app.UseSwaggerUI(c =>
   {
      c.SwaggerEndpoint("/swagger/v1/swagger.json", "PizzaStore API V1");
   });
   
   app.MapGet("/", () => "Hello World!");
   
   app.Run();
   ```

   Visual Studio Code 可能会提示你添加资产以调试项目。 单击对话框中的“`Yes`”。

### 将 EF Core 添加到项目

若要将项存储在待办事项列表中，请安装 `EntityFrameworkCore.InMemory` 包。

1. 在终端窗口中，输入以下代码以添加 EF Core InMemory 包：

   ```console
   dotnet add package Microsoft.EntityFrameworkCore.InMemory --version 6.0
   ```

2. 将 `using Microsoft.EntityFrameworkCore;` 添加到 Program.cs 和 Pizza.cs 文件的顶部。

现在，你已将 EF Core 添加到项目，可以将代码连接到要保存和查询的数据。 若要执行此步骤，将创建 `PizzaDb` 类。 `PizzaDb` 类将执行以下任务：

- 从数据库中的 `Pizza` 列表公开你的 `Pizzas` 属性。
- 使用 `UseInMemoryDatabase` 连接内存数据库存储。 只要应用运行时，数据就会存储在此处。

1. 若要设置内存数据库，请将以下代码添加到 `Pizza.cs` 类底部（在最后的 `}` 的上方）：

   ```csharp
   class PizzaDb : DbContext
   {
       public PizzaDb(DbContextOptions options) : base(options) { }
       public DbSet<Pizza> Pizzas { get; set; }
   }
   ```

   `DbContext` 表示一个连接或会话，用于查询和保存数据库中实体的实例。

2. 将 `using PizzaStore.Models;` 添加到 `Program.cs` 文件的顶部。

3. 在 Program.cs 中，调用 `AddSwaggerGen` 之前，添加以下代码：

   ```csharp
   builder.Services.AddDbContext<PizzaDb>(options => options.UseInMemoryDatabase("items"));
   ```

### 返回项列表

1. 若要从比萨饼列表中的项列表中进行读取，请在调用 `app.Run();` 之前添加以下代码以添加“/pizza”路由：

   ```csharp
   app.MapGet("/pizzas", async (PizzaDb db) => await db.Pizzas.ToListAsync());
   ```

### 运行应用程序

1. 通过调用 `dotnet run` 来运行应用。 此操作会生成应用，并将应用托管在 5000-5300 范围内的某个端口上。 HTTPS 会在 7000-7300 范围内为应用选择一个端口。

    备注

   如果要替代随机端口选择行为，可以设置要在 launchSettings.json 中使用的端口。

   ```bash
   dotnet run
   ```

   下面是输出在终端中的情况：

   ```output
   Building...
    info: Microsoft.Hosting.Lifetime[14]
          Now listening on: https://localhost:7200
    info: Microsoft.Hosting.Lifetime[14]
          Now listening on: http://localhost:5100
    info: Microsoft.Hosting.Lifetime[0]
          Application started. Press Ctrl+C to shut down.
    info: Microsoft.Hosting.Lifetime[0]
          Hosting environment: Development
    info: Microsoft.Hosting.Lifetime[0]
          Content root path: /<path>/PizzaStore
   ```

2. 在浏览器中转到 *https://localhost:{PORT}/swagger*。 选择 `GET /pizzas` 按钮，你会看到列表在 `Response body` 下为空。

### 创建新项

让我们将新任务 POST 到你先前创建的 `app.MapGet` 下的比萨饼列表。

```csharp
app.MapPost("/pizza", async (PizzaDb db, Pizza pizza) =>
{
    await db.Pizzas.AddAsync(pizza);
    await db.SaveChangesAsync();
    return Results.Created($"/pizza/{pizza.Id}", pizza);
});
```

### 测试 API

返回到 Swagger，此时应会看到 `POST/pizza`。 向比萨饼列表添加新项：

1. 选择“POST /pizza”。

2. 选择“试用”。

3. 将请求正文替换为以下内容：

   ```json
   {
       "name": "Pepperoni",
       "description": "A classic pepperoni pizza"
   }
   ```

4. 选择“执行”。

### 读取列表中的项

读取列表中的项：

1. 选择“GET /pizzas”。
2. 选择“试用”。
3. 选择“执行”。

`Response body` 将包含刚刚添加的项。

```json
[
  {
    "id": 1,
    "name": "Pepperoni",
    "description": "A classic pepperoni pizza"
  }
]
```

若要根据 `id` GET 项目，请将代码添加到前面创建的 `app.MapPost` 路由下。

```csharp
app.MapGet("/pizza/{id}", async (PizzaDb db, int id) => await db.Pizzas.FindAsync(id));
```

若要查看此内容，可以访问 *https://localhost:{PORT}/pizza/1* 或使用 Swagger UI。 由于使用的是内存数据库，在重启应用程序后不会列出前面创建的比萨饼，因此需要再次输入。

### 更新项

1. 若要更新现有项目，请将代码添加到你创建的 `GET /pizza/{id}` 路由下：

   ```csharp
   app.MapPut("/pizza/{id}", async (PizzaDb db, Pizza updatepizza, int id) =>
   {
       var pizza = await db.Pizzas.FindAsync(id);
       if (pizza is null) return Results.NotFound();
       pizza.Name = updatepizza.Name;
       pizza.Description = updatepizza.Description;
       await db.SaveChangesAsync();
       return Results.NoContent();
   });
   ```

2. 在 Swagger UI 中选择“PUT /pizza/{id}”。

3. 选择“试用”。

4. 在“ID”文本框中，输入 1。

5. 最后，更新 `Request body`。 粘贴以下 JSON 并将 `name` 更改为 `Pineapple`。

   ```json
    {
       "id": 1,
       "name": "Pineapple",
     }
   ```

6. 选择“执行”。

若要测试代码，请滚动回 `GET /pizza/{id}`。 比萨饼现在的名称为 `Pineapple`。

### 删除项

1. 若要更新现有项目，请将代码添加到前面创建的 `PUT /pizza/{id}` 下：

   ```csharp
   app.MapDelete("/pizza/{id}", async (PizzaDb db, int id) =>
   {
     var pizza = await db.Pizzas.FindAsync(id);
     if (pizza is null)
     {
       return Results.NotFound();
     }
     db.Pizzas.Remove(pizza);
     await db.SaveChangesAsync();
     return Results.Ok();
   });
   ```

2. 现在，请尝试使用 Swagger 接口删除某个项。

在本单元中，你将 EF Core 添加到现有的最小 API 应用程序，并使用内存数据库来存储数据。 接下来，你将了解如何使用实际数据库来存储数据，以便在应用程序关闭期间保持数据。

## 将 SQLite 数据库提供程序与 EF Core 结合使用

在前面的单元中，你学习了如何将数据持久保存到内存数据库。 将数据持久保存到内存数据库在开发中非常有用。 但是，由于在应用程序重启时所有数据都将丢失，因此它并不适合用于生产。 在生产环境中，应将数据持久保存到数据库，如 SQL Server、MySQL、PostgreSQL 或 SQLite。

### 数据库提供程序从应用程序代码中抽象化数据库访问

通过抽象层（如 Entity Framework (EF) Core）执行数据库访问的好处之一是，它将应用程序与数据库提供程序分离。 你可以更改数据库提供程序，而无需重写数据库访问代码。 你无法在不影响应用程序代码的情况下切换数据库提供程序，但更改会最小化并本地化。

使用 EF Core 的相关优势在于，你可以重用代码、经验和数据访问库，以便与任何其他 EF Core 数据库提供程序一起使用。

在本教程中，你将使用 [SQLite 数据库](https://www.sqlite.org/index.html)，但也可以使用一个更好的方法。 EF Core 当前支持超过 20 个数据库提供程序。 这些提供程序已在[文档](https://docs.microsoft.com/zh-CN/ef/core/providers/?tabs=dotnet-core-cli%3Fazure-portal%3Dtrue)中列出。

### 添加新数据库提供程序的步骤

通常，你将使用以下步骤来实现新数据库提供程序：

1. 将一个或多个 NuGet 包添加到项目中，以包含数据库提供程序。
2. 配置数据库连接。
3. 在 ASP.NET Core 服务中配置数据库提供程序。
4. 执行数据库迁移。

## 练习 - 将 SQLite 数据库提供程序与 EF Core 结合使用

在此之前，你已将数据保存在内存数据库中。 此数据库在开发应用程序时非常容易设置和使用，但数据不是持久的。 因此，在应用程序重启时数据将丢失。 在部署应用程序之前，需要将数据持久保存到数据库。

在此练习中，你将升级应用程序以使用关系数据库来存储数据。 你将使用 SQLite 来存储数据。

### 设置 SQLite 数据库

完成以下部分以设置 SQLite 数据库。

#### 安装以下工具和包

使用 .NET CLI 和 Visual Studio 包管理器 UI，安装下列包：

- [SQLite EF Core 数据库提供程序](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Sqlite/6.0.0)：可以通过名为[数据库提供程序](https://docs.microsoft.com/zh-CN/ef/core/providers/?tabs=dotnet-core-cli%3Fazure-portal%3Dtrue)的插件库访问许多不同的数据库。 以下包是用于 Entity Framework (EF) Core 的 SQLite 数据库提供程序。

  ```console
  dotnet add package Microsoft.EntityFrameworkCore.Sqlite --version 6.0
  ```

- [EF Core 工具](https://docs.microsoft.com/zh-CN/ef/core/cli/dotnet)：EF Core 工具执行设计时开发任务。 例如，它们基于现有数据库创建迁移、应用迁移和生成模型代码。

  ```console
  dotnet tool install --global dotnet-ef
  ```

- [Microsoft.EntityFrameworkCore.Design](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Design/6.0.0)：包含 EF Core 用于创建数据库的所有设计时逻辑。

  ```console
  dotnet add package Microsoft.EntityFrameworkCore.Design --version 6.0
  ```

### 启用数据库创建

若要启用数据库创建，需要完成两个步骤：

1. 设置数据库连接字符串。
2. 将数据模型迁移到 SQLite 数据库。

### 设置数据库连接字符串

在 Program.cs 的应用生成器 `var builder = WebApplication.CreateBuilder(args);` 下方，添加一个连接字符串。

```csharp
var connectionString = builder.Configuration.GetConnectionString("Pizzas") ?? "Data Source=Pizzas.db";
```

### 将上下文添加到服务

在本教程的 CRUD 部分，你使用的是内存数据库。 现在，要将内存数据库替换为永久性数据库。

将生成服务中的当前内存数据库实现 `builder.Services.AddDbContext<PizzaDb>(options => options.UseInMemoryDatabase("items"));` 替换为此处的 SQLite 数据库：

```csharp
builder.Services.AddSqlite<PizzaDb>(connectionString);
```

### 迁移数据模型

利用 EF Core 迁移工具，你现在可以开始首次迁移 `InitialCreate`。 在终端窗口中，运行 `migrations` 命令：

```console
   dotnet ef migrations add InitialCreate
```

EF Core 将在项目目录中创建一个名为“Migrations”的文件夹，该文件夹包含两个文件，其中包含表示数据库迁移的代码。

### 创建数据库和架构

完成迁移后，可以使用它来创建数据库和架构。

在终端窗口中，运行以下 `database update` 命令，将迁移应用到数据库：

```console
   dotnet ef database update
```

你应在项目目录中看到新创建的 Pizzas.db 文件。

### 运行和测试应用程序

现在，你已经有了一个后备数据库，更改将永久保留。

若要测试应用程序，请在终端窗口中运行 `dotnet run` 命令，并在 Swagger UI 中与 API 交互。 可以使用 Ctrl+C 命令停止运行应用程序。 在 macOS 上使用 Cmd+C。 然后再次运行该应用程序，并验证更改是否仍然保留。



## 8.4 `Restsharp` v107

### [Quick start | RestSharp](https://restsharp.dev/intro.html)

#### Introduction

#### 前言

WARNING

警告

RestSharp v107 changes the library API surface and its behaviour significantly. We advise looking at [v107](https://restsharp.dev/v107/) docs to understand how to migrate to the latest version of RestSharp.

RestSharp v107显著地改变了API库的表现及其行为。我们建议大家查看v107号文档以理解如何通过定期查看最新版本说明。

The main purpose of RestSharp is to make synchronous and asynchronous calls to remote resources over HTTP. As the name suggests, the main audience of RestSharp are developers who use REST APIs. However, RestSharp can call any API over HTTP, as long as you have the resource URI and request parameters that you want to send comply with W3C HTTP standards.

RestSharp重要目的是通过Http接口实现对远程资源的同步或异步调用。正如名字所示，RestSharp主要面向那些使用REST APIs的群体。

One of the main challenges of using HTTP APIs for .NET developers is to work with requests and responses of different kinds and translate them to complex C# types. RestSharp can take care of serializing the request body to JSON or XML and deserialize the response. It can also form a valid request URI based on different parameter kinds - path, query, form or body.

NET开发人员使用HTTP API的主要挑战之一是处理不同类型的请求和响应，并将其转换为复杂的C类型。RestSharp可以将请求体序列化为JSON或XML，并反序列化响应。它还可以基于不同的参数类型（路径、查询、表单或主体）形成有效的请求URI。

##### [#](https://restsharp.dev/intro.html#getting-started)Getting Started 

##### 开始

Before you can use RestSharp in your application, you need to add the NuGet package. You can do it using your IDE or the command line:

如果你的应用需要使用RestSharp，你可以添加NuGet包。你可以使用IDE添加或者在命令行输入以下命令：

```text
dotnet add package RestSharp
```

##### [#](https://restsharp.dev/intro.html#basic-usage)Basic Usage 

##### 基本用法

If you only have a few number of one-off requests to make to an API, you can use RestSharp like so:

如果只需要向API发送少量或一次性请求，你可以使用RestSharp，例如：

```csharp
using RestSharp;
using RestSharp.Authenticators;

var client = new RestClient("https://api.twitter.com/1.1") {
    Authenticator = new HttpBasicAuthenticator("username", "password")
};
var request = new RestRequest("statuses/home_timeline.json");
var response = await client.GetAsync(request, cancellationToken);
```

It will return a `RestResponse` back, which contains all the information returned from the remote server. You have access to the headers, content, HTTP status and more.

它将返回一个“response”，其中包含从远程服务器返回的所有信息。您可以访问标题、内容、HTTP状态等。

We recommend using the generic overloads like `Get<T>` to automatically deserialize the response into .NET classes.

我们建议使用“Get”之类的泛型重载将响应自动反序列化为.NET类。

recommend：推荐，overloads ：重载， automatically [ˌɔːtəˈmætɪkli] ：自动地，deserialize ：反序列化

For example:

举个栗子🌰：

```csharp
using RestSharp;
using RestSharp.Authenticators;

var client = new RestClient("https://api.twitter.com/1.1");
client.Authenticator = new HttpBasicAuthenticator("username", "password");

var request = new RestRequest("statuses/home_timeline.json", DataFormat.Json);

var timeline = await client.GetAsync<HomeTimeline>(request, cancellationToken);
```

The most important difference, however, that async methods that are named after HTTP methods return the `Task<T>` instead of `Task<IRestResponse<T>>`. Because it means that you won't get an error response if the request fails, those methods throw an exception.

然而，最重要的区别是，以HTTP方法命名的异步方法返回`Task<T>`而不是`Task<IRestResponse<T>`。因为这意味着如果请求失败，您将不会得到错误响应，所以这些方法会引发异常。

All `ExecuteAsync` overloads, however, behave in the same way as `Execute` and return the `IRestResponse` or `IRestResponse<T>`.

然而，所有`ExecuteAsync`重载的行为方式都与`Execute`相同，并返回`IRESResponse`或`IRESresponse<T>`。

Read [here](https://restsharp.dev/error-handling.html) about how RestSharp handles exceptions.

阅读[此处](https://restsharp.dev/error-handling.html)关于RestSharp如何处理异常。

##### [#](https://restsharp.dev/intro.html#content-type)Content type

##### [#](https://restsharp.dev/intro.html#content-type)内容类型

RestSharp supports sending XML or JSON body as part of the request. To add a body to the request, simply call `AddJsonBody` or `AddXmlBody` method of the `IRestRequest` instance.

RestSharp支持将XML或JSON正文作为请求的一部分发送。要将主体添加到请求中，只需调用`IRestRequest`实例的`AddJsonBody`或`AddXmlBody`方法。

There is no need to set the `Content-Type` or add the `DataFormat` parameter to the request when using those methods, RestSharp will do it for you.

使用这些方法时，无需设置`Content Type`或向请求中添加`DataFormat`参数，RestSharp将为您完成此操作。

RestSharp will also handle both XML and JSON responses and perform all necessary deserialization tasks, depending on the server response type. Therefore, you only need to add the `Accept` header if you want to deserialize the response manually.

RestSharp还将处理XML和JSON响应，并根据服务器响应类型执行所有必要的反序列化任务。因此，如果要手动反序列化响应，只需添加`Accept`标头。

For example, only you'd only need these lines to make a request with JSON body:

例如，您只需要这些行就可以使用JSON主体发出请求：

```csharp
var request = new RestRequest("address/update").AddJsonBody(updatedAddress);
var response = await client.PostAsync<AddressUpdateResponse>(request);
```

Read more about serialization and deserialization [here](https://restsharp.dev/serialization.html).

在[此处](https://restsharp.dev/serialization.html)阅读有关序列化和反序列化的更多信息。

##### [#](https://restsharp.dev/intro.html#response)Response

##### [#](https://restsharp.dev/intro.html#response)响应

When you use `ExecuteAsync`, you get an instance of `RestResponse` back that has the `Content` property, which contains the response as string. You can find other useful properties there, like `StatusCode`, `ContentType` and so on. If the request wasn't successful, you'd get a response back with `IsSuccessful` property set to `false` and the error explained in the `ErrorException` and `ErrorMessage` properties.

当您使用`ExecuteAsync`时，您会得到一个具有`Content`属性的`RestResponse`实例，该实例包含了string类型的响应。您可以在那里找到其他有用的属性，如`StatusCode`、`ContentType`等。如果请求未成功，您将返回一个响应，其中`IsSuccessful`属性设置为`false`，错误在`ErrorException`和`ErrorMessage`属性中解释。

When using typed `ExecuteAsync<T>`, you get an instance of `RestResponse<T>` back, which is identical to `RestResponse` but also contains the `T Data` property with the deserialized response.

当使用类型化的`ExecuteAsync<T>`时，返回一个`RestResponse<T>`，它与`RestResponse`相同但也包含反序列化响应的`T Data`属性。

None of `ExecuteAsync` overloads throw if the remote server returns an error. You can inspect the response and find the status code, error message, and, potentially, an exception.

如果远程服务器返回错误，`ExecuteAsync`重载都不会抛出。您可以检查响应并找到状态代码、错误消息以及可能的异常。

Extensions like `GetAsync<T>` will not return the whole `RestResponse<T>` but just a deserialized response. These extensions will throw an exception if the remote server returns an error. The exception will tell you what status code was returned by the server.

像`GetAsync<T>`这样的扩展不会返回整个`restreponse<T>`，而只是一个反序列化的响应。如果远程服务器返回错误，这些扩展将引发异常。异常将告诉您服务器返回了什么状态代码。

[Help us by improving this page! open in new window](https://github.com/restsharp/RestSharp/edit/dev/docs/intro.md)

[帮助我们改进此页面！在新窗口中打开](https://github.com/restsharp/RestSharp/edit/dev/docs/intro.md)

Last Updated: 2022/7/21 17:09:28

最后更新：2022/7/21 17:09:28

Contributors: Marcel Juen

贡献者：Marcel Juen

### Usage

### 使用说明

#### Recommended usage

#### 推荐使用

RestSharp works best as the foundation for a proxy class for your API. Each API would most probably require different settings for `RestClient`. Hence, a dedicated API class (and its interface) gives you sound isolation between different `RestClient` instances and make them testable.

RestSharp最适合作为API代理类的基础。每个API很可能需要不同的`RestClient`设置。因此，一个专用的API类（及其接口）可以在不同的`RestClient`实例之间提供良好的隔离，并是他们具备可测试性。

Essentially, RestSharp is a wrapper around `HttpClient` that allows you to do the following:

本质上，RestSharp是`HttpClient`的包装器，允许您执行以下操作：

- Add default parameters of any kind (not just headers) to the client, once
- 将任何类型的默认参数（不只是头参数）添加到客户端一次
- Add parameters of any kind to each request (query, URL segment, form, attachment, serialized body, header) in a straightforward way
- 以简单的方式向每个请求添加任何类型的参数（查询、URL段、表单、附件、序列化正文、标头）
- Serialize the payload to JSON or XML if necessary
- 在必要情况下，将负载序列化为JSON或XML
- Set the correct content headers (content type, disposition, length, etc.)
- 设置正确的内容标题（内容类型、配置、长度等）
- Handle the remote endpoint response
- 处理远程端点响应
- Deserialize the response from JSON or XML if necessary
- 如果需要，从JSON或XML反序列化响应

For example, let's look at a simple Twitter API v2 client, which uses OAuth2 machine-to-machine authentication. For it to work, you would need to have access to the Twitter Developers portal, a project, and an approved application inside the project with OAuth2 enabled.

例如，让我们看看一个简单的TwitterAPI v2客户端，它使用OAuth2机器对机器身份验证。要使其工作，您需要访问Twitter开发者门户、一个项目和项目内部的一个已批准的应用程序，并启用OAuth2。

##### [#](https://restsharp.dev/usage.html#authenticator)Authenticator

##### [#](https://restsharp.dev/usage.html#authenticator)验证程序

Before we can call the API itself, we need to get a bearer token. Twitter exposes an endpoint `https://api.twitter.com/oauth2/token`. As it follows the OAuth2 conventions, the code can be used to create an authenticator for some other vendors.

在调用API本身之前，我们需要获得一个载体。Twitter公开了一个端点`https://api.twitter.com/oauth2/token`.由于遵循OAuth2约定，该代码可用于为其他一些供应商创建验证器。

First, we need a model for deserializing the token endpoint response. OAuth2 uses snake case for property naming, so we need to decorate model properties with `JsonPropertyName` attribute:

首先，我们需要一个反序列化令牌端点响应的模型。OAuth2使用snake case进行属性命名，因此我们需要使用`JsonPropertyName`属性装饰模型属性：

```csharp
record TokenResponse {
    [JsonPropertyName("token_type")]
    public string TokenType { get; init; }
    [JsonPropertyName("access_token")]
    public string AccessToken { get; init; }
}
```

Next, we create the authenticator itself. It needs the API key and API key secret to call the token endpoint using basic HTTP authentication. In addition, we can extend the list of parameters with the base URL to convert it to a more generic OAuth2 authenticator.

接下来，我们创建验证器本身。它需要API密钥和API密钥密钥来使用基本HTTP身份验证调用令牌端点。此外，我们可以使用基本URL扩展参数列表，以将其转换为更通用的OAuth2身份验证器。

The easiest way to create an authenticator is to inherit from the `AuthanticatorBase` base class:

创建验证器的最简单方法是从`AuthanticatorBase`基类继承：

```csharp
public class TwitterAuthenticator : AuthenticatorBase {
    readonly string _baseUrl;
    readonly string _clientId;
    readonly string _clientSecret;

    public TwitterAuthenticator(string baseUrl, string clientId, string clientSecret) : base("") {
        _baseUrl      = baseUrl;
        _clientId     = clientId;
        _clientSecret = clientSecret;
    }

    protected override async ValueTask<Parameter> GetAuthenticationParameter(string accessToken) {
        var token = string.IsNullOrEmpty(Token) ? await GetToken() : Token;
        return new HeaderParameter(KnownHeaders.Authorization, token);
    }
}
```

During the first call made by the client using the authenticator, it will find out that the `Token` property is empty. It will then call the `GetToken` function to get the token once and reuse the token going forward.

在客户端使用身份验证器进行的第一次调用期间，它将发现“令牌”属性为空。然后它将调用`GetToken`函数来获取令牌一次，并继续重用令牌。

Now, we need to implement the `GetToken` function in the class:

现在，我们需要在类中实现`GetToken`函数：

```csharp
async Task<string> GetToken() {
    var options = new RestClientOptions(_baseUrl);
    using var client = new RestClient(options) {
        Authenticator = new HttpBasicAuthenticator(_clientId, _clientSecret),
    };

    var request = new RestRequest("oauth2/token")
        .AddParameter("grant_type", "client_credentials");
    var response = await client.PostAsync<TokenResponse>(request);
    return $"{response!.TokenType} {response!.AccessToken}";
}
```

As we need to make a call to the token endpoint, we need our own short-lived instance of `RestClient`. Unlike the actual Twitter client, it will use the `HttpBasicAuthenticator` to send the API key and secret as the username and password. The client then gets disposed as we only use it once.

当我们需要调用令牌端点时，我们需要自己的`RestClient`临时实例。与实际的Twitter客户端不同，它将使用`HttpBasicAuthenticator`发送API密钥和密码作为用户名和密码。然后客户机被处理掉，因为我们只使用它一次。

Here we add a POST parameter `grant_type` with `client_credentials` as its value. At the moment, it's the only supported value.

这里我们添加了一个POST参数`grant_type`，其值为`client_credentials`。目前，它是唯一受支持的值。

The POST request will use the `application/x-www-form-urlencoded` content type by default.

默认情况下，POST请求将使用`application/x-www-form-urlencoded`内容类型。

##### [#](https://restsharp.dev/usage.html#api-client)API client

##### [#](https://restsharp.dev/usage.html#api-client)API 客服端

Now, we can start creating the API client itself. Here we start with a single function that retrieves one Twitter user. Let's being by defining the API client interface:

现在，我们可以开始创建API客户端本身了。这里我们从一个函数开始，该函数检索一个Twitter用户。让我们通过定义API客户端接口：

```csharp
public interface ITwitterClient {
    Task<TwitterUser> GetUser(string user);
}
```

As the function returns a `TwitterUser` instance, we need to define it as a model:

由于函数返回一个`TwitterUser`实例，我们需要将其定义为一个模型：

```csharp
public record TwitterUser(string Id, string Name, string Username);
```

When that is done, we can implement the interface and add all the necessary code blocks to get a working API client.

完成后，我们可以实现该接口并添加所有必要的代码块，以获得一个工作的API客户端。

The client class needs the following:

客户端类需要以下内容：

- A constructor, which accepts API credentials to pass to the authenticator
- 构造函数，它接受API凭据以传递给身份验证器
- A wrapped `RestClient` instance with the Twitter API base URI pre-configured
- 预先配置了Twitter API基本URI的包装`RestClient`实例
- The `TwitterAuthenticator` that we created previously as the client authenticator
- 我们之前创建的`TwitterAuthenticator`是客户端身份验证器
- The actual function to get the user
- 获取用户的实际函数

```csharp
public class TwitterClient : ITwitterClient, IDisposable {
    readonly RestClient _client;

    public TwitterClient(string apiKey, string apiKeySecret) {
        var options = new RestClientOptions("https://api.twitter.com/2");

        _client = new RestClient(options) {
            Authenticator = new TwitterAuthenticator("https://api.twitter.com", apiKey, apiKeySecret)
        };
    }

    public async Task<TwitterUser> GetUser(string user) {
        var response = await _client.GetJsonAsync<TwitterSingleObject<TwitterUser>>(
            "users/by/username/{user}",
            new { user }
        );
        return response!.Data;
    }

    record TwitterSingleObject<T>(T Data);

    public void Dispose() {
        _client?.Dispose();
        GC.SuppressFinalize(this);
    }
}
```

The code above includes a couple of things that go beyond the "basics", and so we won't cover them here:

上面的代码包含了一些超出“基础”的内容，因此我们将不在这里介绍它们：

- The API client class needs to be disposable, so that it can dispose of the wrapped `HttpClient` instance
- API客户端类需要是一次性的，这样它就可以处理包装好的`HttpClient`实例
- Twitter API returns wrapped models. In this case, we use the `TwitterSingleObject` wrapper. In other methods, you'd need a similar object with `T[] Data` to accept collections
- Twitter API返回包装模型。在本例中，我们使用`TwitterSingleObject`包装器。在其他方法中，需要具有`T[] Data`的类似对象来接受集合

You can find the full example code in [this gistopen in new window](https://gist.github.com/alexeyzimarev/62d77bb25d7aa5bb4b9685461f8aabdd).

您可以在[新窗口的gistopen](https://gist.github.com/alexeyzimarev/62d77bb25d7aa5bb4b9685461f8aabdd)中找到完整的示例代码。

Such a client can and should be used *as a singleton*, as it's thread-safe and authentication-aware. If you make it a transient dependency, you'll keep bombarding Twitter with token requests and effectively half your request limit.

这样的客户端可以而且应该*作为单例*使用，因为它是线程安全的，并且支持身份验证。如果你让它成为一个暂时的依赖，你会不断地用令牌请求轰炸Twitter，有效地降低了你的请求限制。

You can, for example, register it in the DI container:

例如，您可以在DI容器中注册它：

```csharp
services.AddSingleton<ITwitterClient>(
    new TwitterClient(
        Configuration["Twitter:ApiKey"],
        Configuration["Twitter:ApiKeySecret"]
    )
);
```

#### [#](https://restsharp.dev/usage.html#create-a-request)Create a request

#### [#](https://restsharp.dev/usage.html#create-a-request)创建请求

Before making a request using `RestClient`, you need to create a request instance:

在使用`RestClient`发出请求之前，您需要创建一个请求实例：

```csharp
var request = new RestRequest(resource); // resource is the sub-path of the client base path
```

The default request type is `GET` and you can override it by setting the `Method` property. You can also set the method using the constructor overload:

默认的请求类型是`GET`，您可以通过设置`Method`属性来设置它。

```csharp
var request = new RestRequest(resource, Method.Post);
```

After you've created a `RestRequest`, you can add parameters to it. Below, you can find all the parameter types supported by RestSharp.

创建`RestRequest`后，可以向其添加参数。在下面，您可以找到RestSharp支持的所有参数类型。

##### [#](https://restsharp.dev/usage.html#http-header)Http Header

##### [#](https://restsharp.dev/usage.html#http-header)Http头参数

Adds the parameter as an HTTP header that is sent along with the request. The header name is the parameter's name and the header value is the value.

将参数添加为随请求一起发送的HTTP标头。标题名称是参数的名称，标题值是值。

Content-Type

内容类型

RestSharp will use the correct content type by default. Avoid adding the `Content-Type` header manually to your requests unless you are absolutely sure it is required. You can add a custom content type to the [body parameter](https://restsharp.dev/usage.html#request-body) itself.

默认情况下，RestSharp将使用正确的内容类型。避免将`Content Type`标头手动添加到请求中，除非您绝对确定它是必需的。可以将自定义内容类型添加到[主体参数](https://restsharp.dev/usage.html#request-body)本身。

##### [#](https://restsharp.dev/usage.html#get-or-post)Get or Post

`GetOrPost` behaves differently based on the method. If you execute a GET call, RestSharp will append the parameters to the Url in the form `url?name1=value1&name2=value2`.

`GetOrPost`基于函数而表现不同。如果执行GET调用，RestSharp将以“Url”的形式将参数附加到`url?name1=value1&name2=value 2`。

On a POST or PUT Requests, it depends on whether you have files attached to a Request. If not, the Parameters will be sent as the body of the request in the form `name1=value1&name2=value2`. Also, the request will be sent as `application/x-www-form-urlencoded`.

对于POST或PUT请求，这取决于您是否将文件附加到请求。如果没有，参数将作为请求主体以`name1=value1&name2=value 2`的形式发送。此外，请求将以`application/x-www-form-urlencoded`的形式发送。

In both cases, name and value will automatically be url-encoded.

在这两种情况下，名称和值将自动进行url编码。

If you have files, RestSharp will send a `multipart/form-data` request. Your parameters will be part of this request in the form:

如果您有文件，RestSharp将发送一个`multipart/form-data`请求。您的参数将在以下表格中作为此请求的一部分：

```text
Content-Disposition: form-data; name="parameterName"

ParameterValue
```

##### Post 和 Put 的区别

- `Put:` 如果两个请求相同，后一个请求会把第一个请求覆盖掉。（ 所以PUT用来改资源(更新) ）
- `Post:` 后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

###### [#](https://restsharp.dev/usage.html#addobject)AddObject

You can avoid calling `AddParameter` multiple times if you collect all the parameters in an object, and then use `AddObject`. For example, this code:

如果收集对象中的所有参数，然后使用`AddObject`，则可以避免多次调用`AddParameter`。例如，以下代码：

```csharp
var params = new {
    status = 1,
    priority = "high",
    ids = new [] { "123", "456" }
};
request.AddObject(params);
```

is equivalent to:

相当于：

```csharp
request.AddParameter("status", 1);
request.AddParameter("priority", "high");
request.AddParameter("ids", "123,456");
```

Remember that `AddObject` only works if your properties have primitive types. It also works with collections of primitive types as shown above.

请记住，`AddObject`仅在属性具有基元类型时有效。它还可以处理基元类型的集合，如上所示。

If you need to override the property name or format, you can do it using the `RequestProperty` attribute. For example:

如果需要重写属性名称或格式，可以使用`RequestProperty`属性。例如：

```csharp
public class RequestModel {
    // override the name and the format
    [RequestAttribute(Name = "from_date", Format = "d")]
    public DateTime FromDate { get; set; }
}

// add it to the request
request.AddObject(new RequestModel { FromDate = DateTime.Now });
```

In this case, the request will get a GET or POST parameter named `from_date` and its value would be the current date in short date format.

在这种情况下，请求将获得一个名为`from_date`的GET或POST参数，其值将是短日期格式的当前日期。

##### [#](https://restsharp.dev/usage.html#url-segment)Url Segment

##### [#](https://restsharp.dev/usage.html#url-segment)Url 段

Unlike `GetOrPost`, this `ParameterType` replaces placeholder values in the `RequestUrl`:

与`GetOrPost`不同，此`ParameterType`替换了`RequestUrl`中的占位符值：

```csharp
var request = new RestRequest("health/{entity}/status")
    .AddUrlSegment("entity", "s2");
```

When the request executes, RestSharp will try to match any `{placeholder}` with a parameter of that name (without the `{}`) and replace it with the value. So the above code results in `health/s2/status` being the url.

当请求执行时，RestSharp将尝试将任何`{placeholder}` 与该名称的参数（不带`{}`）匹配，并将其替换为值。因此，上面的代码导致`health/s2/status`是url。

##### [#](https://restsharp.dev/usage.html#request-body)Request Body

##### [#](https://restsharp.dev/usage.html#request-body)请求主体

If this parameter is set, its value will be sent as the body of the request.

如果设置了此参数，则其值将作为请求正文发送。

We recommend using `AddJsonBody` or `AddXmlBody` methods instead of `AddParameter` with type `BodyParameter`. Those methods will set the proper request type and do the serialization work for you.

我们建议使用`AddJsonBody`或`AddXmlBody`方法，而不是类型为`BodyParameter`的`AddParameter`。这些方法将设置正确的请求类型并为您执行序列化工作。

###### [#](https://restsharp.dev/usage.html#addstringbody)AddStringBody

If you have a pre-serialized payload like a JSON string, you can use `AddStringBody` to add it as a body parameter. You need to specify the content type, so the remote endpoint knows what to do with the request body. For example:

如果您有一个预序列化的负载（如JSON字符串），则可以使用`AddStringBody`将其添加为body参数。您需要指定内容类型，以便远程端点知道如何处理请求主体。例如：

```csharp
const json = "{ data: { foo: \"bar\" } }";
request.AddStringBody(json, ContentType.Json);
```

You can specify a custom body content type if necessary. The `contentType` argument is available in all the overloads that add a request body.

如有必要，可以指定自定义正文内容类型。`contentType`参数在添加请求体的所有重载中都可用。

###### [#](https://restsharp.dev/usage.html#addjsonbody)AddJsonBody

When you call `AddJsonBody`, it does the following for you:

当您调用`AddJsonBody`时，它会为您执行以下操作：

- Instructs the RestClient to serialize the object parameter as JSON when making a request
- 指示RestClient在发出请求时将对象参数序列化为JSON
- Sets the content type to `application/json`
- 将内容类型设置为`application/json`
- Sets the internal data type of the request body to `DataType.Json`
- 将请求主体的内部数据类型设置为`DataType.Json`

WARNING

警告

Do not send JSON string or some sort of `JObject` instance to `AddJsonBody`; it won't work! Use `AddStringBody` instead.

Here is the example:

不要将JSON字符串或某种`JObject`实例发送到`AddJsonBody`；应用对此并不支持！改用`AddStringBody`。
下面是一个例子：

```csharp
var param = new MyClass { IntData = 1, StringData = "test123" };
request.AddJsonBody(param);
```

###### [#](https://restsharp.dev/usage.html#addxmlbody)AddXmlBody

When you call `AddXmlBody`, it does the following for you:

当您调用`AddXmlBody`时，它会为您执行以下操作：

- Instructs the RestClient to serialize the object parameter as XML when making a request
- 指示RestClient在发出请求时将对象参数序列化为XML
- Sets the content type to `application/xml`
- 将内容类型设置为`application/xml`
- Sets the internal data type of the request body to `DataType.Xml`
- 将请求主体的内部数据类型设置为`DataType.Xml`

WARNING

警告

Do not send XML string to `AddXmlBody`; it won't work!

不要将XML字符串发送到`AddXmlBody`；应用对此并不支持！

##### [#](https://restsharp.dev/usage.html#query-string)Query String

`QueryString` works like `GetOrPost`, except that it always appends the parameters to the url in the form `url?name1=value1&name2=value2`, regardless of the request method.

`QueryString`的工作方式类似于`GetOrPost`，只是它总是以 url 的形式将参数附加到`url？name1=value1&name2=value 2`，而不考虑请求方法。

Example:

例子：

```csharp
var client = new RestClient("https://search.me");
var request = new RestRequest("search")
    .AddParameter("foo", "bar");
var response = await client.GetAsync<SearchResponse>(request);
```

It will send a `GET` request to `https://search.me/search?foo=bar")`.

它会向`https://search.me/search?foo=bar")`发送一个 `GET` 请求 。

For `POST`-style requests you need to add the query string parameter explicitly:

对于`POST`样式的请求，需要显式添加查询字符串参数：

```csharp
request.AddQueryParameter("foo", "bar");
```

In some cases, you might need to prevent RestSharp from encoding the query string parameter. To do so, set the `encode` argument to `false` when adding the parameter:

在某些情况下，您可能需要防止RestSharp对查询字符串参数进行编码。为此，在添加参数时，将`encode`参数设置为`false`：

```csharp
request.AddQueryParameter("foo", "bar/fox", false);
```

#### [#](https://restsharp.dev/usage.html#making-a-call)Making a call

#### [#](https://restsharp.dev/usage.html#making-a-call)进行通话

Once you've added all the parameters to your `RestRequest`, you are ready to make a request.

将所有参数添加到`RestRequest`后，就可以发出请求了。

`RestClient` has a single function for this:

`RestClient`有一个功能：

```csharp
public async Task<RestResponse> ExecuteAsync(
    RestRequest request, 
    CancellationToken cancellationToken = default
)
```

You can also avoid setting the request method upfront and use one of the overloads:

您还可以避免预先设置请求方法，并使用以下重载之一：

```csharp
Task<RestResponse> ExecuteGetAsync(RestRequest request, CancellationToken cancellationToken)
Task<RestResponse> ExecutePostAsync(RestRequest request, CancellationToken cancellationToken)
Task<RestResponse> ExecutePutAsync(RestRequest request, CancellationToken cancellationToken)
```

When using any of those methods, you will get the response content as string in `response.Content`.

当使用这些方法中的任何一种时，您将在`response.content`中获得字符串形式的响应内容。

RestSharp can deserialize the response for you. To use that feature, use one of the generic overloads:

RestSharp可以为您反序列化响应。要使用该功能，请使用以下通用重载之一：

```csharp
Task<RestResponse<T>> ExecuteAsync<T>(RestRequest request, CancellationToken cancellationToken)
Task<RestResponse<T>> ExecuteGetAsync<T>(RestRequest request, CancellationToken cancellationToken)
Task<RestResponse<T>> ExecutePostAsync<T>(RestRequest request, CancellationToken cancellationToken)
Task<RestResponse<T>> ExecutePutAsync<T>(RestRequest request, CancellationToken cancellationToken)
```

All the overloads that return `RestResponse` or `RestResponse<T>` don't throw an exception if the server returns an error. Read more about it [here](https://restsharp.dev/error-handling.html).

如果服务器返回错误，则所有返回`Resresponse`或`Response<T>`的重载不会引发异常。[点击此处](https://restsharp.dev/error-handling.html)了解更多信息.

If you just need a deserialized response, you can use one of the extensions:

如果只需要反序列化响应，可以使用以下扩展之一：

```csharp
Task<T> GetAsync<T>(RestRequest request, CancellationToken cancellationToken)
Task<T> PostAsync<T>(RestRequest request, CancellationToken cancellationToken)
Task<T> PutAsync<T>(RestRequest request, CancellationToken cancellationToken)
Task<T> HeadAsync<T>(RestRequest request, CancellationToken cancellationToken)
Task<T> PatchAsync<T>(RestRequest request, CancellationToken cancellationToken)
Task<T> DeleteAsync<T>(RestRequest request, CancellationToken cancellationToken)
```

Those extensions will throw an exception if the server returns an error, as there's no other way to float the error back to the caller.

如果服务器返回错误，这些扩展将抛出异常，因为没有其他方法将错误浮回调用方式。

##### [#](https://restsharp.dev/usage.html#json-requests)JSON requests

##### [#](https://restsharp.dev/usage.html#json-requests)JSON 返回体

To make a simple `GET` call and get a deserialized JSON response with a pre-formed resource string, use this:

要进行一个简单的`GET`调用，并使用预先形成的资源字符串获取反序列化的JSON响应，请使用以下命令：

```csharp
var response = await client.GetJsonAsync<TResponse>("endpoint?foo=bar", cancellationToken);
```

You can also use a more advanced extension that uses an object to compose the resource string:

您还可以使用更高级的扩展，该扩展使用对象来组成资源字符串：

```csharp
var client = new RestClient("https://example.org");
var args = new {
    id = "123",
    foo = "bar"
};
// Will make a call to https://example.org/endpoint/123?foo=bar
var response = await client.GetJsonAsync<TResponse>("endpoint/{id}", args, cancellationToken);
```

It will search for the URL segment parameters matching any of the object properties and replace them with values. All the other properties will be used as query parameters.

它将搜索与任何对象属性匹配的URL段参数，并将其替换为值。所有其他属性将用作查询参数。

Similar things are available for `POST` requests.

类似的事情也适用于`POST`请求。

```csharp
var request = new CreateOrder("123", "foo", 10100);
// Will post the request object as JSON to "orders" and returns a 
// JSON response deserialized to OrderCreated  
var result = client.PostJsonAsync<CreateOrder, OrderCreated>("orders", request, cancellationToken);
```

```csharp
var request = new CreateOrder("123", "foo", 10100);
// Will post the request object as JSON to "orders" and returns a 
// status code, not expecting any response body
var statusCode = client.PostJsonAsync("orders", request, cancellationToken);
```

The same two extensions also exist for `PUT` requests (`PutJsonAsync`);

同样的两个扩展也存在于`PUT`请求（`PutJsonAsync`）；

##### [#](https://restsharp.dev/usage.html#json-streaming-apis)JSON streaming APIs

For HTTP API endpoints that stream the response data (like [Twitter search streamopen in new window](https://developer.twitter.com/en/docs/twitter-api/tweets/filtered-stream/api-reference/get-tweets-search-stream)) you can use RestSharp with `StreamJsonAsync<T>`, which returns an `IAsyncEnumerable<T>`:

对于传输响应数据的HTTP API端点（如[Twitter search streamopen in new window](https://developer.twitter.com/en/docs/twitter-api/tweets/filtered-stream/api-reference/get-tweets-search-stream))您可以将RestSharp与`StreamJsonAsync<T>`一起使用，它返回一个`iasyncnumerable<T>`：

```csharp
public async IAsyncEnumerable<SearchResponse> SearchStream(
    [EnumeratorCancellation] CancellationToken cancellationToken = default
) {
    var response = _client.StreamJsonAsync<TwitterSingleObject<SearchResponse>>(
        "tweets/search/stream", cancellationToken
    );

    await foreach (var item in response.WithCancellation(cancellationToken)) {
        yield return item.Data;
    }
}
```

The main limitation of this function is that it expects each JSON object to be returned as a single line. It is unable to parse the response by combining multiple lines into a JSON string.

该函数的主要限制是，它期望每个JSON对象作为单行返回。它无法通过将多行组合成JSON字符串来解析响应。

##### [#](https://restsharp.dev/usage.html#uploading-files)Uploading files

##### [#](https://restsharp.dev/usage.html#uploading-files)上传文件

To add a file to the request you can use the `RestRequest` function called `AddFile`. The main function accepts the `FileParameter` argument:

要向请求中添加文件，可以使用名为`AddFile`的`RestRequest`函数。主函数接受`FileParameter`参数：

```csharp
request.AddFile(fileParameter);
```

You can instantiate the file parameter using `FileParameter.Create` that accepts a bytes array, or `FileParameter.FromFile`, which will load the file from disk.

您可以使用接受字节数组的`FileParameter.Create` 或`FileParameter.FromFile`实例化文件参数，后者将从磁盘加载文件。

There are also extension functions that wrap the creation of `FileParameter` inside:

还有一些扩展函数将`FileParameter`的创建封装其中：

```csharp
// Adds a file from disk
AddFile(parameterName, filePath, contentType);

// Adds an array of bytes
AddFile(parameterName, bytes, fileName, contentType);

// Adds a stream returned by the getFile function
AddFile(parameterName, getFile, fileName, contentType);
```

Remember that `AddFile` will set all the necessary headers, so please don't try to set content headers manually.

请记住，`AddFile`将设置所有必要的标题，因此请不要尝试手动设置内容标题。

##### [#](https://restsharp.dev/usage.html#downloading-binary-data)Downloading binary data

##### [#](https://restsharp.dev/usage.html#downloading-binary-data)下载二进制数据

There are two functions that allow you to download binary data from the remote API.

有两个函数允许您从远程API下载二进制数据。

First, there's `DownloadDataAsync`, which returns `Task<byte[]>`. It will read the binary response to the end, and return the whole binary content as a byte array. It works well for downloading smaller files.

首先是`DownloadDataAsync`，它返回`Task<byte[]>`。它将读取二进制响应到末尾，并将整个二进制内容作为字节数组返回。它适用于下载较小的文件。

For larger responses, you can use `DownloadStreamAsync` that returns `Task<Stream>`. This function allows you to open a stream reader and asynchronously stream large responses to memory or disk.

对于较大的响应，您可以使用`DownloadStreamAsync`，它返回`Task<Stream>`。此函数允许您打开流读取器，并将大型响应异步流传输到内存或磁盘。

#### [#](https://restsharp.dev/usage.html#blazor-support)Blazor support

#### [#](https://restsharp.dev/usage.html#blazor-support)Blazor支持

Inside a Blazor webassembly app, you can make requests to external API endpoints. Microsoft examples show how to do it with `HttpClient`, and it's also possible to use RestSharp for the same purpose.

在Blazor webassembly应用程序中，您可以向外部API端点发出请求。微软的例子展示了如何使用`HttpClient`，也可以使用RestSharp实现同样的目的。

You need to remember that webassembly has some platform-specific limitations. Therefore, you won't be able to instantiate `RestClient` using all of its constructors. In fact, you can only use `RestClient` constructors that accept `HttpClient` or `HttpMessageHandler` as an argument. If you use the default parameterless constructor, it will call the option-based constructor with default options. The options-based constructor will attempt to create an `HttpMessageHandler` instance using the options provided, and it will fail with Blazor, as some of those options throw thw "Unsupported platform" exception.

您需要记住，webassembly有一些特定于平台的限制。因此，您将无法使用其所有构造函数实例化`RestClient`。实际上，只能使用接受`HttpClient`或`HttpMessageHandler`作为参数的`RestClient`构造函数。如果使用默认的无参数构造函数，它将使用默认选项调用基于选项的构造函数。基于选项的构造函数将尝试使用提供的选项创建`HttpMessageHandler`实例，但在Blazor中会失败，因为其中一些选项会引发“不受支持的平台”异常。

Here is an example how to register the `RestClient` instance globally as a singleton:

下面是一个如何将`RestClient`实例全局注册为单例的示例：

```csharp
builder.Services.AddSingleton(new RestClient(new HttpClient()));
```

Then, on a page you can inject the instance:

然后，在页面上可以注入实例：

```html
@page "/fetchdata"
@using RestSharp
@inject RestClient _restClient
```

And then use it:

之后会启用下列代码：

```csharp
@code {
    private WeatherForecast[]? forecasts;

    protected override async Task OnInitializedAsync() {
        forecasts = await _restClient.GetJsonAsync<WeatherForecast[]>("http://localhost:5104/weather");
    }

    public class WeatherForecast {
        public DateTime Date { get; set; }
        public int TemperatureC { get; set; }
        public string? Summary { get; set; }
        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    }
}
```

In this case, the call will be made to a WebAPI server hosted at `http://localhost:5104/weather`. Remember that if the WebAPI server is not hosting the webassembly itself, it needs to have a CORS policy configured to allow the webassembly origin to access the API endpoint from the browser.

在这种情况下，将调用位于的WebAPI服务器`http://localhost:5104/weather`. 请记住，如果WebAPI服务器不是webassembly本身的宿主，则需要配置CORS策略，以允许WebAssemblyOrigin从浏览器访问API端点。

[Help us by improving this page! open in new window](https://github.com/restsharp/RestSharp/edit/dev/docs/usage.md)

[帮助我们改进此页面！在新窗口中打开](https://github.com/restsharp/RestSharp/edit/dev/docs/usage.md)

Last Updated: 2022/7/21 17:09:28

Contributors: Marcel Juen



### Serialization

### 序列化

RestSharp has JSON and XML serializers built in.

RestSharp内置了JSON和XML序列化程序。

TIP

小提示

The default behavior of RestSharp is to swallow deserialization errors and return `null` in the `Data` property of the response. Read more about it in the [Error Handling](https://restsharp.dev/error-handling.html).

RestSharp的默认行为是吞下反序列化错误，并在响应的“Data”属性中返回“null”。在[错误处理](https://restsharp.dev/error-handling.html)中了解更多信息.

#### [#](https://restsharp.dev/serialization.html#json)JSON

The default JSON serializer uses `System.Text.Json`, which is a part of .NET since .NET 6. For earlier versions, it is added as a dependency. There are also a few serializers provided as additional packages.

默认的JSON序列化程序使用`System.Text.Json`，从.NET 6开始就是.NET的一部分。对于早期版本，它是作为依赖项添加的。还有一些序列化程序作为附加包提供。

By default, RestSharp will use `JsonSerializerDefaults.Web` configuration. If necessary, you can specify your own options:

默认情况下，RestSharp将使用`JsonSerializerDefaults.Web`。如有必要，您可以指定自己的选项：

```csharp
client.UseSystemTextJson(new JsonSerializerOptions {...});
```

#### [#](https://restsharp.dev/serialization.html#xml)XML

The default XML serializer is `DotNetXmlSerializer`, which uses `System.Xml.Serialization` library from .NET.

默认的XML序列化程序是使用了.Net中`System.Xml.Serialization` 库的`DotNetXmlSerializer`模块。

In previous versions of RestSharp, the default XML serializer was a custom RestSharp XML serializer. To make the code library size smaller, that serializer is now available as a separate package [`RestSharp.Serializers.Xml`open in new window](https://www.nuget.org/packages/RestSharp.Serializers.Xml). You can add it back if necessary by installing the package and adding it to the client:

在以前版本的RestSharp中，默认的XML序列化程序是自定义的RestSharp XML序列化程序。为了减小代码库的大小，该序列化程序现在可以作为一个单独的包[`RestSharp.Serializers.Xml`在新窗口中打开](https://www.nuget.org/packages/RestSharp.Serializers.Xml). 如果需要，您可以通过安装软件包并将其添加到客户端来将其添加回来：

```csharp
client.UseXmlSerializer();
```

As before, you can supply three optional arguments for a custom namespace, custom root element, and if you want to use `SerializeAs` and `DeserializeAs` attributed.

如前所述，您可以为自定义名称空间、自定义根元素提供三个可选参数，如果您想使用`SerializeAs` 和`DeserializeAs` 属性。

#### [#](https://restsharp.dev/serialization.html#newtonsoftjson-aka-json-net)NewtonsoftJson (aka Json.Net)

The `NewtonsoftJson` package is the most popular JSON serializer for .NET. It handles all possible scenarios and is very configurable. Such a flexibility comes with the cost of performance. If you need speed, keep the default JSON serializer.

`NewtonsoftJson`包是.NET中最流行的JSON序列化程序。它处理所有可能的场景，并且可配置性极强。这种灵活性伴随着性能成本。如果需要速度，请保留默认的JSON序列化程序。

RestSharp support Json.Net serializer via a separate package [`RestSharp.Serializers.NewtonsoftJson`open in new window](https://www.nuget.org/packages/RestSharp.Serializers.NewtonsoftJson).

RestSharp支持Json。Net序列化程序通过单独的包[`RestSharp.Serializers.NewtonsoftJson`在新窗口中打开](https://www.nuget.org/packages/RestSharp.Serializers.NewtonsoftJson).

WARNING

警告

Please note that `RestSharp.Newtonsoft.Json` package is not provided by RestSharp, is marked as obsolete on NuGet, and no longer supported by its creator.

请注意RestSharp不提供`RestSharp.Newtonsoft.Json`包，在NuGet上标记为已过时，其创建者不再支持它。

Use the extension method provided by the package to configure the client:

使用包提供的扩展方法配置客户端：

```csharp
client.UseNewtonsoftJson();
```

The serializer configures some options by default:

序列化程序默认配置一些选项：

```csharp
JsonSerializerSettings DefaultSettings = new JsonSerializerSettings {
    ContractResolver     = new CamelCasePropertyNamesContractResolver(),
    DefaultValueHandling = DefaultValueHandling.Include,
    TypeNameHandling     = TypeNameHandling.None,
    NullValueHandling    = NullValueHandling.Ignore,
    Formatting           = Formatting.None,
    ConstructorHandling  = ConstructorHandling.AllowNonPublicDefaultConstructor
};
```

If you need to use different settings, you can supply your instance of `JsonSerializerSettings` as a parameter for the extension method.

如果需要使用不同的设置，可以将`JsonSerializerSettings`实例作为扩展方法的参数提供。

#### [#](https://restsharp.dev/serialization.html#custom)Custom

#### [#](https://restsharp.dev/serialization.html#custom)约定

You can also implement your custom serializer. To support both serialization and deserialization, you must implement the `IRestSerializer` interface.

您还可以实现自定义序列化程序。要同时支持序列化和反序列化，必须实现`IRestSerializer`接口。

Here is an example of a custom serializer that uses `System.Text.Json`:

下面是一个使用`System.Text.Json`的自定义序列化程序示例：

```csharp
public class SimpleJsonSerializer : IRestSerializer {
    public string Serialize(object obj) => JsonSerializer.Serialize(obj);

    public string Serialize(Parameter bodyParameter) => Serialize(bodyParameter.Value);

    public T Deserialize<T>(IRestResponse response) => JsonSerializer.Deserialize<T>(response.Content);

    public string[] SupportedContentTypes { get; } = {
        "application/json", "text/json", "text/x-json", "text/javascript", "*+json"
    };

    public string ContentType { get; set; } = "application/json";

    public DataFormat DataFormat { get; } = DataFormat.Json;
}
```

The value of the `SupportedContentTypes` property will be used to match the serializer with the response `Content-Type` headers.

`SupportedContentTypes`属性的值将用于将序列化程序与响应`Content-Type`标头匹配。

The `ContentType` property will be used when making a request so the server knows how to handle the payload.

`ContentType`属性将在发出请求时使用，以便服务器知道如何处理有效负载。

[Help us by improving this page! open in new window](https://github.com/restsharp/RestSharp/edit/dev/docs/serialization.md)

Last Updated: 2022/7/21 17:09:28

Contributors: Marcel Juen

### Authenticators 

### 证书

RestSharp includes authenticators for basic HTTP (Authorization header), NTLM and parameter-based systems.

RestSharp包括用于基本HTTP（授权头）、NTLM和基于参数的系统的认证器。

#### [#](https://restsharp.dev/authenticators.html#basic-authentication)Basic Authentication

#### [#](https://restsharp.dev/authenticators.html#basic-authentication)基本认证

The `HttpBasicAuthenticator` allows you pass a username and password as a basic `Authorization` header using a base64 encoded string.

`HttpBasicAuthenticator`允许您使用base64编码字符串将用户名和密码作为基本的`Authorization`头传递。

```csharp
var client = new RestClient("http://example.com");
client.Authenticator = new HttpBasicAuthenticator("username", "password");
```

##### [#](https://restsharp.dev/authenticators.html#oauth1)OAuth1

For OAuth1 authentication the `OAuth1Authenticator` class provides static methods to help generate an OAuth authenticator.

对于OAuth1身份验证，`OAuth1Authenticator`类提供静态方法来帮助生成OAuth身份验证器。

##### [#](https://restsharp.dev/authenticators.html#request-token)Request token

##### [#](https://restsharp.dev/authenticators.html#request-token)请求令牌

This method requires a `consumerKey` and `consumerSecret` to authenticate.

此方法需要`consumerKey`和`consumerSecret`进行身份验证。

```csharp
var client = new RestClient("http://example.com");
client.Authenticator = OAuth1Authenticator.ForRequestToken(consumerKey, consumerSecret);
```

##### [#](https://restsharp.dev/authenticators.html#access-token)Access token

##### [#](https://restsharp.dev/authenticators.html#access-token)访问令牌

This method retrieves an access token when provided `consumerKey`, `consumerSecret`, `oauthToken`, and `oauthTokenSecret`.

当提供`consumerKey`、`consumerSecret`、`oauthToken`和`oauthTokenSecret`时，此方法检索访问令牌。

```csharp
client.Authenticator = OAuth1Authenticator.ForAccessToken(
    consumerKey, consumerSecret, oauthToken, oauthTokenSecret
);
```

This method also includes an optional parameter to specify the `OAuthSignatureMethod`.

此方法还包括一个可选参数，用于指定`OAuthSignatureMethod`。

```csharp
client.Authenticator = OAuth1Authenticator.ForAccessToken(
    consumerKey, consumerSecret, oauthToken, oauthTokenSecret, 
    OAuthSignatureMethod.PlainText
);
```

##### [#](https://restsharp.dev/authenticators.html#_0-legged-oauth)0-legged OAuth

The same access token authenticator can be used in 0-legged OAuth scenarios by providing `null` for the `consumerSecret`.

通过为`consumerSecret`提供`null`，可以在0-legged OAuth场景中使用相同的访问令牌验证器。

```csharp
client.Authenticator = OAuth1Authenticator.ForAccessToken(
    consumerKey, null, oauthToken, oauthTokenSecret
);
```

#### [#](https://restsharp.dev/authenticators.html#oauth2)OAuth2

RestSharp has two very simple authenticators to send the access token as part of the request.

RestSharp有两个非常简单的验证器，将访问令牌作为请求的一部分发送。

`OAuth2UriQueryParameterAuthenticator` accepts the access token as the only constructor argument, and it will send the provided token as a query parameter `oauth_token`.

`OAuth2UriQueryParameterAuthenticator`接受访问令牌作为唯一的构造函数参数，并将提供的令牌作为查询参数`oauth_token`发送。

`OAuth2AuthorizationRequestHeaderAuthenticator` has two constructors. One only accepts a single argument, which is the access token. The other constructor also allows you to specify the token type. The authenticator will then add an `Authorization` header using the specified token type or `OAuth` as the default token type, and the token itself.

`OAuth2AuthorizationRequestHeaderAuthenticator`有两个构造函数。只接受一个参数，即访问令牌。另一个构造函数还允许您指定令牌类型。然后，验证器将使用指定的令牌类型或`OAuth`作为默认令牌类型以及令牌本身添加`Authorization`标头。

For example:

举个例子：

```csharp
client.Authenticator = new OAuth2AuthorizationRequestHeaderAuthenticator(
    token, "Bearer"
);
```

The code above will tell RestSharp to send the bearer token with each request as a header. Essentially, the code above does the same as the sample for `JwtAuthenticator` below.

上面的代码将告诉RestSharp发送承载令牌，并将每个请求作为报头。本质上，上面的代码与下面的`JwtAuthenticator`示例相同。

As those authenticators don't do much to get the token itself, you might be interested in looking at our [sample OAuth2 authenticator](https://restsharp.dev/usage.html#authenticator), which requests the token on its own.

由于这些验证器对获取令牌本身没有太大作用，您可能有兴趣查看我们的[示例OAuth2验证器](https://restsharp.dev/usage.html#authenticator)，它自己请求令牌。

#### [#](https://restsharp.dev/authenticators.html#jwt)JWT

The JWT authentication can be supported by using `JwtAuthenticator`. It is a very simple class that can be constructed like this:

可以通过使用“JwtAuthenticator”来支持JWT认证。它是一个非常简单的类，可以这样构造：

```csharp
var authenticator = new JwtAuthenticator(myToken);
```

For each request, it will add an `Authorization` header with the value `Bearer <your token>`.

对于每个请求，它将添加一个值为 `Bearer <your token>`的`Authorization` 标头。

As you might need to refresh the token from, you can use the `SetBearerToken` method to update the token.

由于您可能需要从中刷新令牌，因此可以使用 `SetBearerToken` 方法更新令牌。

#### [#](https://restsharp.dev/authenticators.html#custom-authenticator)Custom Authenticator

#### [#](https://restsharp.dev/authenticators.html#custom-authenticator)自定义验证器

You can write your own implementation by implementing `IAuthenticator` and registering it with your RestClient:

您可以通过实现 `IAuthenticator` 并将其注册到RestClient来编写自己的实现：

```csharp
var client = new RestClient();
client.Authenticator = new SuperAuthenticator(); // implements IAuthenticator
```

The `Authenticate` method is the very first thing called upon calling `RestClient.Execute` or `RestClient.Execute<T>`. The `Authenticate` method is passed the `RestRequest` currently being executed giving you access to every part of the request data (headers, parameters, etc.)

`Authenticate` 方法是调用`RestClient.Execute` 或 `RestClient.Execute<T>`时调用的第一个方法。`Authenticate`方法被传递给当前正在执行的`RestRequest` ，允许您访问请求数据的每个部分（头、参数等）

You can find an example of a custom authenticator that fetches and uses an OAuth2 bearer token [here](https://restsharp.dev/usage.html#authenticator).

您可以在[这里](https://restsharp.dev/usage.html#authenticator)找到一个获取并使用OAuth2承载令牌的自定义验证器示例.

[Help us by improving this page! open in new window](https://github.com/restsharp/RestSharp/edit/dev/docs/authenticators.md)

Last Updated: 2022/7/21 17:09:28

Contributors: Marcel Juen



### Error handling

### 错误处理

If there is a network transport error (network is down, failed DNS lookup, etc), or any kind of server error (except 404), `RestResponse.ResponseStatus` will be set to `ResponseStatus.Error`, otherwise it will be `ResponseStatus.Completed`.

如果存在网络传输错误（网络关闭、DNS查找失败等），或任何类型的服务器错误（404除外），`RestResponse.ResponseStatus` 将设置为`ResponseStatus.Error`，否则将为 `ResponseStatus.Completed`。

If an API returns a 404, `ResponseStatus` will still be `Completed`. If you need access to the HTTP status code returned you will find it at `RestResponse.StatusCode`. The `Status` property is an indicator of completion independent of the API error handling.

如果API返回404，`ResponseStatus` 仍将保持 `Completed`状态。如果您需要访问返回的HTTP状态代码，您可以在`RestResponse.StatusCode`中找到它。`Status`属性是独立于API错误处理的完成指示符。

Normally, RestSharp doesn't throw an exception if the request fails.

通常，如果请求失败，RestSharp不会抛出异常。

However, it is possible to configure RestSharp to throw in different situations, when it normally doesn't throw in favour of giving you the error as a property.

然而，可以将RestSharp配置为在不同的情况下抛出，当它通常不抛出时，将错误作为属性提供给您。

| Property  属性                | Behavior  表现                                               |
| ----------------------------- | ------------------------------------------------------------ |
| `FailOnDeserializationError`  | Changes the default behavior when failed deserialization results in a successful response with an empty `Data` property of the response. Setting this property to `true` will tell RestSharp to consider failed deserialization as an error and set the `ResponseStatus` to `Error` accordingly.<br />当失败的反序列化导致响应`Data`属性为空时，更改默认行为。将此属性设置为`true`将告诉RestSharp将失败的反序列化视为错误，并相应地将`ResponseStatus`设置为`error`。 |
| `ThrowOnDeserializationError` | Changes the default behavior when failed deserialization results in empty `Data` property of the response. Setting this property to `true` will tell RestSharp to throw when deserialization fails.<br />当失败的反序列化导致响应的空`Data`属性时，更改默认行为。将此属性设置为`true`将告诉RestSharp在反序列化失败时抛出。 |
| `ThrowOnAnyError`             | Setting this property to `true` changes the default behavior and forces RestSharp to throw if any errors occurs when making a request or during deserialization.<br />将此属性设置为`true`将更改默认行为，并在发出请求或反序列化期间发生任何错误时强制RestSharp抛出。 |

Those properties are available for the `RestClient` instance and will be used for all request made with that instance.

这些属性可用于`RestClient`实例，并将用于该实例的所有请求。

WARNING

警告

Please be aware that deserialization failures will only work if the serializer throws an exception when deserializing the response. Many serializers don't throw by default, and just return a `null` result. RestSharp is unable to figure out why `null` is returned, so it won't fail in this case. Check the serializer documentation to find out if it can be configured to throw on deserialization error.

请注意，只有在序列化程序在反序列化响应时引发异常时，反序列化失败才会起作用。默认情况下，许多序列化程序不抛出，只返回`null`结果。RestSharp无法找出返回`null`的原因，因此在这种情况下它不会失败。请查看序列化程序文档，了解是否可以将其配置为引发反序列化错误。

There are also slight differences on how different overloads handle exceptions.

不同的重载处理异常的方式也略有不同。

Asynchronous generic methods `GetAsync<T>`, `PostAsync<T>` and so on, which aren't a part of `RestClient` interface (those methods are extension methods) return `Task<T>`. It means that there's no `RestResponse` to set the response status to error. We decided to throw an exception when such a request fails. It is a trade-off between the API consistency and usability of the library. Usually, you only need the content of `RestResponse` instance to diagnose issues and most of the time the exception would tell you what's wrong.

异步泛型方法`GetAsync<T>`、`PostAsync<T>`等等，它们不是`RestClient`接口的一部分（这些方法是扩展方法），返回`Task<T>`。这意味着没有`RestResponse`将响应状态设置为错误。当这样的请求失败时，我们决定抛出一个异常。这是API一致性和库可用性之间的权衡。通常，您只需要`RestResponse`实例的内容来诊断问题，大多数情况下，异常会告诉您出了什么问题。

Below you can find how different extensions deal with errors. Note that functions, which don't throw by default, will throw exceptions when `ThrowOnAnyError` is set to `true`.

下面您可以找到不同的扩展如何处理错误。请注意，默认情况下不抛出的函数在`ThrowOnAnyError`设置为`true`时将抛出异常。

| Function              | Throws on errors |
| :-------------------- | :--------------- |
| `ExecuteAsync`        | No               |
| `ExecuteGetAsync`     | No               |
| `ExecuteGetAsync<T>`  | No               |
| `ExecutePostAsync`    | No               |
| `ExecutePutAsync`     | No               |
| `ExecuteGetAsync<T>`  | No               |
| `ExecutePostAsync<T>` | No               |
| `ExecutePutAsync<T>`  | No               |
| `GetAsync`            | Yes              |
| `GetAsync<T>`         | Yes              |
| `PostAsync`           | Yes              |
| `PostAsync<T>`        | Yes              |
| `PatchAsync`          | Yes              |
| `PatchAsync<T>`       | Yes              |
| `DeleteAsync`         | Yes              |
| `DeleteAsync<T>`      | Yes              |
| `OptionsAsync`        | Yes              |
| `OptionsAsync<T>`     | Yes              |
| `HeadAsync`           | Yes              |
| `HeadAsync<T>`        | Yes              |

In addition, all the functions for JSON requests, like `GetJsonAsync` and `PostJsonAsyn` throw an exception if the HTTP call fails.

此外，如果HTTP调用失败，JSON请求的所有函数，如`GetJsonAsync`和`PostJsonAsyn`，都会引发异常。

[Help us by improving this page! open in new window](https://github.com/restsharp/RestSharp/edit/dev/docs/error-handling.md)

Last Updated: 2022/7/21 17:09:28

Contributors: Marcel Juen



*******************



## RestSharp v107

The latest version of RestSharp is v107. It's a major upgrade, which contains quite a few breaking changes.

RestSharp的最新版本是v107。这是一次重大升级，其中包含了许多突破性的更改。

The most important change is that RestSharp stop using the legacy `HttpWebRequest` class, and uses well-known 'HttpClient' instead. This move solves lots of issues, like hanging connections due to improper `HttpClient` instance cache, updated protocols support, and many other problems.

最重要的变化是RestSharp停止使用遗留的`HttpWebRequest`类，而是使用著名的“HttpClient”。这一举措解决了许多问题，如由于不正确的`HttpClient`实例缓存导致的连接挂起、更新的协议支持以及许多其他问题。

Another big change is that `SimpleJson` is retired completely from the code base. Instead, RestSharp uses `JsonSerializer` from the `System.Text.Json` package, which is the default serializer for ASP.NET Core.

另一个重大变化是`SimpleJson`完全从代码库中退出。相反，RestSharp使用 ASP.NET Core默认序列化工具`System.Text.Json`中的`JsonSerializer` 包。

Finally, most of the interfaces are now gone.

最后，大多数接口现在都消失了。

### [#](https://restsharp.dev/v107/#brief-migration-guide)Brief migration guide

### [#](https://restsharp.dev/v107/#brief-migration-guide)简要迁移指南

#### [#](https://restsharp.dev/v107/#restclient-and-options)RestClient and options

#### [#](https://restsharp.dev/v107/#restclient-and-options)RestClient和选项

The `IRestClient` interface is deprecated. You will be using the `RestClient` class instance.

`IRestClient`接口已弃用。您将使用`RestClient`类实例。

Most of the client options are moved to `RestClientOptions`. If you can't find the option you used to set on `IRestClient`, check the options, it's probably there.

大多数客户端选项都移动到`RestClientOptions`。如果找不到用于在`IRestClient`上设置的选项，请检查选项，它可能在那里。

This is how you can instantiate the client using the simplest possible way:

这是如何使用最简单的方式实例化客户端：

```csharp
var client = new RestClient("https://api.myorg.com");
```

For customizing the client, use `RestClientOptions`:

要自定义客户端，请使用`RestClientOptions`：

```csharp
var options = new RestClientOptions("https://api.myorg.com") {
    ThrowOnAnyError = true,
    Timeout = 1000
};
var client = new RestClient(options);
```

You can still change serializers and add default parameters to the client.

您仍然可以更改序列化程序并向客户端添加默认参数。

#### [#](https://restsharp.dev/v107/#restclient-lifecycle)RestClient lifecycle

#### [#](https://restsharp.dev/v107/#restclient-lifecycle)RestClient生命周期

Do not instantiate `RestClient` for each HTTP call. RestSharp creates a new instance of `HttpClient` internally, and you will get lots of hanging connections, and eventually exhaust the connection pool.

不要为每个HTTP调用实例化`RestClient`。RestSharp在内部创建了一个新的`HttpClient`实例，您将获得大量挂起的连接，并最终耗尽连接池。

If you use a dependency-injection container, register your API client as a singleton.

如果使用依赖注入容器，请将API客户端注册为单例。

#### [#](https://restsharp.dev/v107/#body-parameters)Body parameters[#](https://restsharp.dev/v107/#body-parameters)主体参数

Beware that most of the code generators, like Postman C# code gen, generate code for RestSharp before v107, and that code is broken. Such code worked mostly due to obscurity of previous RestSharp versions API. For example, Postman-generated code tells you to add the content-type header, and the accept header, which in many cases is an anti-pattern. It also posts JSON payload as string, where RestSharp provides you with serialization and deserialization of JSON out of the box.

请注意，大多数代码生成器（如Postman C#code gen）都是在v107之前为RestSharp生成代码的，并且该代码已被破坏。这类代码之所以能正常工作，主要是因为以前的RestSharp版本API晦涩难懂。例如，Postman生成的代码告诉您添加内容类型头和accept头，在许多情况下，这是一种反模式。它还将JSON负载作为字符串发布，其中RestSharp为您提供了JSON的即时序列化和反序列化。

Therefore, please read the [Usage](https://restsharp.dev/usage.html) page and follow our guidelines when using RestSharp v107+.

因此，请阅读[用法](https://restsharp.dev/usage.html)使用RestSharp v107+时，请翻页并遵循我们的指南。

Some of the points to be aware of:

需要注意的一些要点：

- `AddParameter("application/json", ..., ParameterType.RequestBody)` won't work, use `AddBody` instead, or better, `AddJsonBody`.
- `AddParameter("application/json", ..., ParameterType.RequestBody)` 已经弃用, 请改用`AddBody` 替代或更加`AddJsonBody`.
- `AddJsonBody("{ foo: 'bar' }")` won't work (and it never worked), use `AddStringBody`. `AddJsonBody` is for serializable objects, not for strings.
- `AddJsonBody("{ foo: 'bar' }")` 已弃用， 请使用`AddStringBody`。`AddJsonBody` 用于可序列化对象，而不是字符串。
- If your `AddParameter(something, something, ParameterType.RequestBody)` doesn't work, try `AddBody` as it will do its best to figure out what kind of body you're adding.
- 如果您的`AddParameter（something，somethine，ParameterType.RequestBody）`不起作用，请尝试`AddBody`，因为它会尽最大努力找出您要添加的主体类型。

#### [#](https://restsharp.dev/v107/#headers)Headers

Lots of code out there that uses RestSharp has lines like:

很多使用RestSharp的代码都有这样的行：

```csharp
request.AddHeader("Content-Type", "application/json");
request.AddHeader("Accept", "application/json");
```

This is completely unnecessary, and often harmful. The `Content-Type` header is the content header, not the request header. It might be different per individual part of the body when using multipart-form data, for example. RestSharp sets the correct content-type header automatically, based on your body format, so don't override it. The `Accept` header is set by RestSharp automatically based on registered serializers. By default, both XML and JSON are supported. Only change the `Accept` header if you need something else, like binary streams, or plain text.

这是完全不必要的，而且往往是有害的。`Content-Type`报头是内容报头，而不是请求报头。例如，当使用多部分表单数据时，身体的每个部分可能不同。RestSharp根据您的正文格式自动设置正确的内容类型标题，因此不要覆盖它。`Accept`标头由RestSharp根据注册的序列化程序自动设置。默认情况下，支持XML和JSON。只有在需要其他内容（如二进制流或纯文本）时才更改`Accept`标题。

#### [#](https://restsharp.dev/v107/#making-requests)Making requests

#### [#](https://restsharp.dev/v107/#making-requests)发出请求

The `IRestRequest` interface is deprecated. You will be using the `RestRequest` class instance.

`IRestRequest`接口已弃用。您将使用`RestRequest`类实例。

You can still create a request as before:

您仍然可以像以前一样创建请求：

```csharp
var request = new RestRequest();
```

Adding parameters hasn't changed much, except you cannot add cookie parameters to the request. It's because cookies are added to the `HttpMessageHandler` cookie container, which is not accessible inside the request class.

添加参数并没有太大变化，只是不能将cookie参数添加到请求中。这是因为cookie被添加到`HttpMessageHandler`cookie容器中，在请求类中无法访问该容器。

```csharp
var request = new RestRequest()
    .AddQueryParameter("foo", "bar")
    .AddJsonBody(someObject);
```

Quite a few options previously available via `IRestRequest` are now in `RestClientOptions`. It's also because changing those options forced us to use a different HTTP message handler, and it caused hanging connections, etc.

以前通过`IRestRequest`提供的许多选项现在都在`RestClientOptions`中。这也是因为更改这些选项迫使我们使用不同的HTTP消息处理程序，并导致连接挂起等。

When you got a request instance, you can make a call:

当您收到请求实例时，您可以进行调用：

```csharp
var request = new RestRequest()
    .AddQueryParameter("foo", "bar")
    .AddJsonBody(someObject);
var response = await client.PostAsync<MyResponse>(request, cancellationToken);
```

All the synchronous methods are gone. If you absolutely must call without using `async` and `await`, use `GetAwaiter().GetResult()` blocking call.

所有的同步方法都成为过去了。如果绝对必须在不使用`异步`和`等待`的情况下调用，请使用`GetAwaiter().GetResult()` 阻塞调用。

The `IRestResponse` interface is deprecated. You get an instance of `RestResponse` or `RestResponse<T>` in return.

不推荐使用 `IRestResponse` 接口。您将得到一个 `RestResponse` 或`RestResponse<T>` 的实例。

You can also use a simplified API for making POST and PUT requests:

您还可以使用简化的API进行POST和PUT请求：

```csharp
var request = new MyRequest { Data = "foo" };
var response = await client.PostAsync<MyRequest, MyResponse>(request, cancellationToken);
// response will be of type TResponse
```

This way you avoid instantiating `RestRequest` explicitly.

这样可以避免显式实例化`RestRequest`。

#### [#](https://restsharp.dev/v107/#using-your-own-httpclient)Using your own HttpClient

#### [#](https://restsharp.dev/v107/#using-your-own-httpclient)使用您自己的HttpClient

`RestClient` class has two constructors, which accept either `HttpClient` or `HttpMessageHandler` instance.

`RestClient`类有两个构造函数，它们接受`HttpClient`或`HttpMessageHandler`实例。

This way you can use a pre-configured `HttpClient` or `HttpMessageHandler`, customized for your needs.

通过这种方式，您可以使用预先配置的`HttpClient`或`HttpMessageHandler`，根据您的需要进行定制。

#### [#](https://restsharp.dev/v107/#default-serializers)Default serializers

#### [#](https://restsharp.dev/v107/#default-serializers)默认序列化程序

For JSON, RestSharp will use `JsonSerializer` from the `System.Text.Json` package. This package is now referenced by default, and it is the only dependency of the RestSharp NuGet package.

对于JSON，RestSharp将使用`System.Text.Json` 的`JsonSerializer` 包。This package is now referenced by default, and it is the only dependency of the RestSharp NuGet package.

The `Utf8` serializer package is deprecated as the package is not being updated.

`Utf8`序列化程序包已被弃用，因为该包未被更新。

For XML requests and responses RestSharp uses `DotNetXmlSerializer` and `DotNetXmlDeserializer`. Previously used default `XmlSerializer`, `XmlDeserializer`, and `XmlAttrobuteDeserializer` are moved to a separate package `RestSharp.Serializers.Xml`.

对于XML请求和响应，RestSharp使用 `DotNetXmlSerializer` 和 `DotNetXmlDeserializer`。以前使用的默认`XmlSerializer`, `XmlDeserializer`和`XmlAttrobuteDeserializer` 将移动到单独的包`XmlAttrobuteDeserializer`。

#### [#](https://restsharp.dev/v107/#ntlm-authentication)NTLM authentication

#### [#](https://restsharp.dev/v107/#ntlm-authentication)NTLM身份验证

The `NtlmAuthenticator` is deprecated.

`NtlmAuthenticator` 已弃用。

NTLM authenticator was doing nothing more than telling `WebRequest` to use certain credentials. Now with RestSharp, the preferred way would be to set the `Credentials` or `UseDefaultCredentials` property in `RestClientOptions`.

NTLM验证器只不过是告诉`WebRequest` 使用某些凭据。现在使用RestSharp，首选方法是在`RestClientOptions`中设置`Credentials`或`UseDefaultCredentials` 属性。

The reason to remove it was that all other authenticators use `AuthenticatorBase`, which must return a parameter. In general, any authenticator is given a request before its made, so it can do something with it. NTLM doesn't work this way, it needs some settings to be provided for `HttpClientHandler`, which is set up before the `HttpClient` instance is created, and it happens once per RestClient instance, and it cannot be changed per request.

删除它的原因是所有其他验证器都使用`AuthenticatorBase`，它必须返回一个参数。一般来说，任何验证器在发出请求之前都会收到一个请求，因此它可以对其进行处理。NTLM不是以这种方式工作的，它需要为`HttpClientHandler`提供一些设置，该设置是在创建`HttpClient`实例之前设置的，每个RestClient实例都会发生一次，并且不能根据请求进行更改。

#### [#](https://restsharp.dev/v107/#delegating-handlers)Delegating handlers

#### [#](https://restsharp.dev/v107/#delegating-handlers)委托处理程序

You can easily build your own request/response pipeline, as you would with `HttpClient`. RestClient will create an `HttpMessageHandler` instance for its own use, using the options provided. You can, of course, provide your own instance of `HttpMessageHandler` as `RestSharpClient` has a constructor that accepts a custom handler and uses it to create an `HttpClient` instance. However, you'll be on your own with the handler configuration in this case.

您可以轻松构建自己的请求/响应管道，就像使用 `HttpClient`一样。RestClient将使用提供的选项创建一个`HttpMessageHandler`实例供自己使用。当然，您可以提供自己的`HttpMessageHandler`实例，因为`RestSharpClient`有一个接受自定义处理程序的构造函数，并使用它创建`HttpClient`实例。

If you want to build a *pipeline*, use [delegating handlersopen in new window](https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/httpclient-message-handlers). For example, you can use `HttpTracer` to [debug your HTTP callsopen in new window](https://github.com/BSiLabs/HttpTracer) like this:

如果要构建*管道*，请在新窗口中使用[委托handlersopen](https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/httpclient-message-handlers)。例如，您可以这般使用`HttpTracer`来[在新窗口中调试您的HTTP callsopen](https://github.com/BSiLabs/HttpTracer)：

```csharp
var options = new RestClientOptions(_server.Url) {
    ConfigureMessageHandler = handler => 
        new HttpTracerHandler(handler, new ConsoleLogger(), HttpMessageParts.All)
};
var client = new RestClient(options);
```

### [#](https://restsharp.dev/v107/#recommended-usage)Recommended usage

### [#](https://restsharp.dev/v107/#recommended-usage)推荐用法

`RestClient` should be thread-safe. It holds an instance of `HttpClient` and `HttpMessageHandler` inside. Do not instantiate the client for a single call, otherwise you get issues with hanging connections and connection pooling won't be possible.

`RestClient`应该是线程安全的。它在内部保存了`HttpClient`和`HttpMessageHandler`的实例。不要为单个调用实例化客户端，否则会出现挂起连接的问题，连接池将不可能实现。

Do create typed API clients for your use cases. Use a single instance of `RestClient` internally in such an API client for making calls. It would be similar to using typed clients using `HttpClient`, for example:

为您的用例创建类型化API客户端。在这样的API客户端中，在内部使用单个`RestClient`实例进行调用。这类似于使用`HttpClient`的类型化客户端，例如：

```csharp
public class GitHubClient {
    readonly RestClient _client;

    public GitHubClient() {
        _client = new RestClient("https://api.github.com/")
            .AddDefaultHeader(KnownHeaders.Accept, "application/vnd.github.v3+json");
    }

    public Task<GitHubRepo[]> GetRepos()
        => _client.GetAsync<GitHubRepo[]>("users/aspnet/repos");
}
```

Do not use one instance of `RestClient` across different API clients.

不要跨不同的API客户端使用一个`RestClient`实例。

This documentation contains the complete example of a [Twitter API client](https://restsharp.dev/usage.html), which you can use as a reference.

本文档包含[Twitter API客户端](https://restsharp.dev/usage.html)的完整示例，您可以将其用作参考。

### [#](https://restsharp.dev/v107/#presumably-solved-issues)Presumably solved issues

### [#](https://restsharp.dev/v107/#presumably-solved-issues)预计问题处理

The next RestSharp version presumably solves the following issues:

下一个RestSharp版本可能会解决以下问题：

- Connection pool starvation
- 连接池不足
- Hanging open TCP connections
- 挂起打开的TCP连接
- Improper handling of async calls
- 异步调用处理不当
- Various `SimpleJson` serialization quirks
- 各种`SimpleJson`序列化怪症
- HTTP/2 support
- HTTP/2支持
- Intermediate certificate issue
- 中间证书颁发
- Uploading large files (use file parameters with `Stream`)
- 上传大文件（使用带有`流`的文件参数）
- Downloading large files (use `DownloadFileStreamAsync`)
- 下载大文件（使用`DownloadFileStreamAsync`）

### [#](https://restsharp.dev/v107/#deprecated-interfaces)Deprecated interfaces

### [#](https://restsharp.dev/v107/#deprecated-interfaces)弃用的接口

The following interfaces are removed from RestSharp:

从RestSharp中删除了以下接口：

- `IRestClient`
- `IRestRequest`
- `IRestResponse`
- `IHttp`

#### [#](https://restsharp.dev/v107/#motivation)Motivation

#### [#](https://restsharp.dev/v107/#motivation)原因

All the deprecated interfaces had only one implementation in RestSharp, so those interfaces were abstracting nothing. It is now unclear what was the purpose for adding those interfaces initially.

所有不推荐的接口在RestSharp中只有一个实现，因此这些接口没有抽象任何内容。现在还不清楚最初添加这些接口的目的是什么。

What about mocking it, you might ask? The answer is: what would you do if you use a plain `HttpClient` instance? It doesn't implement any interface for the same reason - there's nothing to abstract, and there's only one implementation. We don't recommend mocking `RestClient` in your tests when you are testing against APIs that are controlled by you or people in your organisation. Test your clients against the real thing, as REST calls are I/O-bound. Mocking REST calls is like mocking database calls, and lead to a lot of issues in production even if all your tests pass against mocks.

你可能会问，嘲笑它怎么样？答案是：如果使用普通的`HttpClient`实例，您会怎么做？出于同样的原因，它没有实现任何接口-没有什么可抽象的，只有一个实现。当您针对您或您组织中的人员控制的API进行测试时，我们不建议在测试中模拟`HttpClient`。针对实际情况测试您的客户机，因为REST调用是I/O绑定的。模拟REST调用类似于模拟数据库调用，即使所有测试都通过了模拟，也会在生产中导致许多问题。

As mentioned in [Recommended usage](https://restsharp.dev/v107/#recommended-usage), we advise against using `RestClient` in the application code, and advocate wrapping it inside particular API client classes. Those classes would be under your control, and you are totally free to use interfaces there. If you absolutely must mock, you can mock your interfaces instead.

如[推荐用法](https://restsharp.dev/v107/#recommended-usage)中所述，我们建议不要在应用程序代码中使用`RestClient`，并主张将其包装在特定的API客户端类中。这些类将在您的控制下，您完全可以在那里自由使用接口。如果您确实必须模拟，那么您可以模拟接口。

#### [#](https://restsharp.dev/v107/#mocking)Mocking

#### [#](https://restsharp.dev/v107/#mocking)模拟

Mocking an infrastructure component like RestSharp (or HttpClient) is not the best idea. Even if you check that all the parameters are added correctly to the request, your "unit test" will only give you a false sense of safety that your code actually works. But, you have no guarantee that the remote server will accept your request, or if you can handle the actual response correctly.

模仿RestSharp（或HttpClient）这样的基础设施组件不是最好的主意。即使您检查了所有参数是否正确添加到请求中，您的“单元测试”也只会给您一个错误的安全感，即您的代码实际工作。但是，您不能保证远程服务器会接受您的请求，或者您是否能够正确处理实际响应。

The best way to test HTTP calls is to make some, using the actual service you call. However, you might still want to check if your API client forms requests in a certain way. You might also be sure about what the remote server responds to your calls with, so you can build a set of JSON (or XML) responses, so you can simulate remote calls.

测试HTTP调用的最佳方法是使用您调用的实际服务进行一些测试。但是，您可能仍然希望检查您的API客户端是否以某种方式形成请求。您还可以确定远程服务器用什么响应您的调用，因此可以构建一组JSON（或XML）响应，以便模拟远程调用。

It is perfectly doable without using interfaces. As RestSharp uses `HttpClient` internally, it certainly uses `HttpMessageHandler`. Features like delegating handlers allow you to intercept the request pipeline, inspect the request, and substitute the response. You can do it yourself, or use a library like [MockHttpopen in new window](https://github.com/richardszalay/mockhttp). They have an example provided in the repository README, so we have changed it for RestClient here:

这在不使用接口的情况下是完全可行的。由于RestSharp在内部使用`HttpClient`，它当然使用`HttpMessageHandler`。委托处理程序等功能允许您拦截请求管道、检查请求并替换响应。您可以自己做，也可以使用类似[MockHttpopen in new window](https://github.com/richardszalay/mockhttp)的库。他们在存储库自述文件中提供了一个示例，因此我们在这里为RestClient更改了它：

```csharp
var mockHttp = new MockHttpMessageHandler();

// Setup a respond for the user api (including a wildcard in the URL)
mockHttp.When("http://localhost/api/user/*")
        .Respond("application/json", "{'name' : 'Test McGee'}"); // Respond with JSON

// Instantiate the client normally, but replace the message handler
var client = new RestClient(...) { ConfigureMessageHandler = _ => mockHttp };

var request = new RestRequest("http://localhost/api/user/1234");
var response = await client.GetAsync(request);

// No network connection required
Console.Write(response.Content); // {'name' : 'Test McGee'}
```

#### [#](https://restsharp.dev/v107/#reference)Reference

#### [#](https://restsharp.dev/v107/#reference)参考

Below, you can find members of `IRestClient` and `IRestRequest` with their corresponding status and location in the new API.

在下面，您可以找到`IRestClient`和`IRestRequest`的成员及其在新API中的相应状态和位置。

| `IRestClient` member                                         | Where is it now?                   |
| :----------------------------------------------------------- | :--------------------------------- |
| `CookieContainer`                                            | `RestClient`                       |
| `AutomaticDecompression`                                     | `RestClientOptions`, changed type  |
| `MaxRedirects`                                               | `RestClientOptions`                |
| `UserAgent`                                                  | `RestClientOptions`                |
| `Timeout`                                                    | `RestClientOptions`, `RestRequest` |
| `Authenticator`                                              | `RestClient`                       |
| `BaseUrl`                                                    | `RestClientOptions`                |
| `Encoding`                                                   | `RestClientOptions`                |
| `ThrowOnDeserializationError`                                | `RestClientOptions`                |
| `FailOnDeserializationError`                                 | `RestClientOptions`                |
| `ThrowOnAnyError`                                            | `RestClientOptions`                |
| `PreAuthenticate`                                            | `RestClientOptions`                |
| `BaseHost`                                                   | `RestClientOptions`                |
| `AllowMultipleDefaultParametersWithSameName`                 | `RestClientOptions`                |
| `ClientCertificates`                                         | `RestClientOptions`                |
| `Proxy`                                                      | `RestClientOptions`                |
| `CachePolicy`                                                | `RestClientOptions`, changed type  |
| `FollowRedirects`                                            | `RestClientOptions`                |
| `RemoteCertificateValidationCallback`                        | `RestClientOptions`                |
| `Pipelined`                                                  | Not supported                      |
| `UnsafeAuthenticatedConnectionSharing`                       | Not supported                      |
| `ConnectionGroupName`                                        | Not supported                      |
| `ReadWriteTimeout`                                           | Not supported                      |
| `UseSynchronizationContext`                                  | Not supported                      |
| `DefaultParameters`                                          | `RestClient`                       |
| `UseSerializer(Func<IRestSerializer> serializerFactory)`     | `RestClient`                       |
| `UseSerializer<T>()`                                         | `RestClient`                       |
| `Deserialize<T>(IRestResponse response)`                     | `RestClient`                       |
| `BuildUri(IRestRequest request)`                             | `RestClient`                       |
| `UseUrlEncoder(Func<string, string> encoder)`                | Extension                          |
| `UseQueryEncoder(Func<string, Encoding, string> queryEncoder)` | Extension                          |
| `ExecuteAsync<T>(IRestRequest request, CancellationToken cancellationToken)` | `RestClient`                       |
| `ExecuteAsync<T>(IRestRequest request, Method httpMethod, CancellationToken cancellationToken)` | Extension                          |
| `ExecuteAsync(IRestRequest request, Method httpMethod, CancellationToken cancellationToken)` | Extension                          |
| `ExecuteAsync(IRestRequest request, CancellationToken cancellationToken)` | Extension                          |
| `ExecuteGetAsync<T>(IRestRequest request, CancellationToken cancellationToken)` | Extension                          |
| `ExecutePostAsync<T>(IRestRequest request, CancellationToken cancellationToken)` | Extension                          |
| `ExecuteGetAsync(IRestRequest request, CancellationToken cancellationToken)` | Extension                          |
| `ExecutePostAsync(IRestRequest request, CancellationToken cancellationToken)` | Extension                          |
| `Execute(IRestRequest request)`                              | Deprecated                         |
| `Execute(IRestRequest request, Method httpMethod)`           | Deprecated                         |
| `Execute<T>(IRestRequest request)`                           | Deprecated                         |
| `Execute<T>(IRestRequest request, Method httpMethod)`        | Deprecated                         |
| `DownloadData(IRestRequest request)`                         | Deprecated                         |
| `ExecuteAsGet(IRestRequest request, string httpMethod)`      | Deprecated                         |
| `ExecuteAsPost(IRestRequest request, string httpMethod)`     | Deprecated                         |
| `ExecuteAsGet<T>(IRestRequest request, string httpMethod)`   | Deprecated                         |
| `ExecuteAsPost<T>(IRestRequest request, string httpMethod)`  | Deprecated                         |
| `BuildUriWithoutQueryParameters(IRestRequest request)`       | Removed                            |
| `ConfigureWebRequest(Action<HttpWebRequest> configurator)`   | Removed                            |
| `AddHandler(string contentType, Func<IDeserializer> deserializerFactory)` | Removed                            |
| `RemoveHandler(string contentType)`                          | Removed                            |
| `ClearHandlers()`                                            | Removed                            |

| `IRestRequest` member                                        | Where is it now?                 |
| :----------------------------------------------------------- | :------------------------------- |
| `AlwaysMultipartFormData`                                    | `RestRequest`                    |
| `JsonSerializer`                                             | Deprecated                       |
| `XmlSerializer`                                              | Deprecated                       |
| `AdvancedResponseWriter`                                     | `RestRequest`, changed signature |
| `ResponseWriter`                                             | `RestRequest`, changed signature |
| `Parameters`                                                 | `RestRequest`                    |
| `Files`                                                      | `RestRequest`                    |
| `Method`                                                     | `RestRequest`                    |
| `Resource`                                                   | `RestRequest`                    |
| `RequestFormat`                                              | `RestRequest`                    |
| `RootElement`                                                | `RestRequest`                    |
| `DateFormat`                                                 | `XmlRequest`                     |
| `XmlNamespace`                                               | `XmlRequest`                     |
| `Credentials`                                                | Removed, use `RestClientOptions` |
| `Timeout`                                                    | `RestRequest`                    |
| `ReadWriteTimeout`                                           | Not supported                    |
| `Attempts`                                                   | `RestRequest`                    |
| `UseDefaultCredentials`                                      | Removed, use `RestClientOptions` |
| `AllowedDecompressionMethods`                                | Removed, use `RestClientOptions` |
| `OnBeforeDeserialization`                                    | `RestRequest`                    |
| `OnBeforeRequest`                                            | `RestRequest`, changed signature |
| `Body`                                                       | Removed, use `Parameters`        |
| `AddParameter(Parameter p)`                                  | `RestRequest`                    |
| `AddFile(string name, string path, string contentType)`      | Extension                        |
| `AddFile(string name, byte[] bytes, string fileName, string contentType)` | Extension                        |
| `AddFile(string name, Action<Stream> writer, string fileName, long contentLength, string contentType)` | Extension                        |
| `AddFileBytes(string name, byte[] bytes, string filename, string contentType)` | Extension `AddFile`              |
| `AddBody(object obj, string xmlNamespace)`                   | Deprecated                       |
| `AddBody(object obj)`                                        | Extension                        |
| `AddJsonBody(object obj)`                                    | Extension                        |
| `AddJsonBody(object obj, string contentType)`                | Extension                        |
| `AddXmlBody(object obj)`                                     | Extension                        |
| `AddXmlBody(object obj, string xmlNamespace)`                | Extension                        |
| `AddObject(object obj, params string[] includedProperties)`  | Extension                        |
| `AddObject(object obj)`                                      | Extension                        |
| `AddParameter(string name, object value)`                    | Extension                        |
| `AddParameter(string name, object value, ParameterType type)` | Extension                        |
| `AddParameter(string name, object value, string contentType, ParameterType type)` | Extension                        |
| `AddOrUpdateParameter(Parameter parameter)`                  | Extension                        |
| `AddOrUpdateParameters(IEnumerable<Parameter> parameters)`   | Extension                        |
| `AddOrUpdateParameter(string name, object value)`            | Extension                        |
| `AddOrUpdateParameter(string name, object value, ParameterType type)` | Extension                        |
| `AddOrUpdateParameter(string name, object value, string contentType, ParameterType type)` | Extension                        |
| `AddHeader(string name, string value)`                       | Extension                        |
| `AddOrUpdateHeader(string name, string value)`               | Extension                        |
| `AddHeaders(ICollection<KeyValuePair<string, string>> headers)` | Extension                        |
| `AddOrUpdateHeaders(ICollection<KeyValuePair<string, string>> headers)` | Extension                        |
| `AddCookie(string name, string value)`                       | Extension                        |
| `AddUrlSegment(string name, string value)`                   | Extension                        |
| `AddUrlSegment(string name, string value, bool encode)`      | Extension                        |
| `AddUrlSegment(string name, object value)`                   | Extension                        |
| `AddQueryParameter(string name, string value)`               | Extension                        |
| `AddQueryParameter(string name, string value, bool encode)`  | Extension                        |
| `AddDecompressionMethod(DecompressionMethods decompressionMethod)` | Not supported                    |
| `IncreaseNumAttempts()`                                      | Made internal                    |

[Help us by improving this page! open in new window](https://github.com/restsharp/RestSharp/edit/dev/docs/v107/README.md)

Last Updated: 2022/7/21 17:09:28

Contributors: Marcel Juen

*******************



### Get Help

### 获取帮助

Got issues, questions, suggestions? Please read this page carefully to understand how you can get help working with RestSharp.

有问题、问题或建议吗？请仔细阅读本页，了解如何使用RestSharp获得帮助。

#### [#](https://restsharp.dev/support/#questions)Questions

#### [#](https://restsharp.dev/support/#questions)问题

The most effective way to resolve questions about using RestSharp is StackOverflow.

解决有关使用RestSharp的问题的最有效方法是StackOverflow。

RestSharp has a large user base. Tens of thousands of projects and hundreds of thousands of developers use RestSharp on a daily basis. So, asking questions on **StackOverflow** with [restsharpopen in new window](https://stackoverflow.com/questions/tagged/restsharp) tag would most definitely lead you to a solution.

RestSharp拥有庞大的用户群。数万个项目和数十万开发人员每天都在使用RestSharp。因此，使用[restsharpopen在新窗口中](https://stackoverflow.com/questions/tagged/restsharp)在**StackOverflow**上提问标签绝对会引导您找到解决方案。

WARNING

警告

Please do not use GitHub issues to ask question about using RestSharp.

请不要使用GitHub问题来询问有关使用RestSharp的问题。

#### [#](https://restsharp.dev/support/#discussions)Discussions

#### [#](https://restsharp.dev/support/#discussions)讨论

We have a [mail listopen in new window](http://groups.google.com/group/restsharp) at Google Groups dedicated to discussions about using RestSharp, feature proposals and similar topics. It is perfectly fine to ask questions about using RestSharp at that group too.

我们有一个[谷歌邮箱](http://groups.google.com/group/restsharp)，专门讨论使用RestSharp、功能建议和类似主题的小组。在该组中也可以询问有关使用RestSharp的问题。

#### [#](https://restsharp.dev/support/#bugs-and-issues)Bugs and issues

#### [#](https://restsharp.dev/support/#bugs-and-issues)错误和问题

The last resort to get help when you experience some unexpected behaviour, a crash or anything else that you consider a bug, is submitting an issue at our GitHub repository.

当您遇到一些意外行为、崩溃或任何其他您认为是错误的情况时，获得帮助的最后手段是在我们的GitHub存储库中提交问题。

WARNING

警告

**Do not ignore our contribution guidelines**, otherwise you risk your issue to be closed without being considered. Respect the maintainers, be specific and provide as many details about the issue as you can.

**不要忽视我们的贡献指南**，否则您的问题可能会在未经考虑的情况下被关闭。尊重维护人员，做到具体，并尽可能提供有关问题的详细信息。

Ensure you provide the following in the issue:

确保在问题中提供以下内容：

- Expected behaviour
- 预期行为
- Actual behaviour
- 实际行为
- Why do you think it is an issue, not a misunderstanding
- 你为什么认为这是一个问题，而不是误解
- How the issue can be reproduced: a repository or at least a code snippet
- 如何重现问题：存储库或至少是代码片段
- If RestSharp unexpectedly throws an exception, provide the stack trace
- 如果RestSharp意外抛出异常，请提供堆栈跟踪

#### [#](https://restsharp.dev/support/#contributing)Contributing

#### [#](https://restsharp.dev/support/#contributing)贡献

Although issues are considered as contributions, we strongly suggest helping the community by solving issues that you experienced by submitting a pull request.

尽管问题被视为贡献，但我们强烈建议通过解决提交拉取请求时遇到的问题来帮助社区。

Here are contribution guidelines:

以下是代码贡献指南：

- Make each pull request atomic and exclusive; don't send pull requests for a laundry list of changes.
- 使每个拉取请求具有原子性和排他性；不要发送更改列表的拉取请求。
- Even better, commit in small manageable chunks.
- 优先，以可管理的小块提交。
- Use the supplied `.editorconfig` file to format the code.
- 使用提供的`.editorconfig`文件以格式化代码。
- Any change must be accompanied by a unit test covering the change.
- 任何变更都必须附有涵盖变更的单元测试。
- New tests are preferred to use FluentAssertions.
- 新的测试优选使用FluentAssertions。
- No regions.
- 没有区域。
- No licence header for tested.
- 未测试许可证标题。
- Code must build for .NET Standard 2.0, .NET 5, and .NET 6.
- 代码必须为.NET Standard 2.0、.NET 5和.NET 6构建。
- Test must run on .NET 6.
- 测试必须在.NET 6上运行。
- Use `autocrlf=true` (`git config --global core.autocrlf true`)
- 使用`autocrlf=true` (`git config --global core.autocrlf true`)

#### [#](https://restsharp.dev/support/#sponsor)Sponsor

#### [#](https://restsharp.dev/support/#sponsor)赞助商

You can also support maintainers and motivate them by contributing financially at [Open Collectiveopen in new window](https://opencollective.com/restsharp).

您还可以在[打开Collectiveopen的新窗口中](https://opencollective.com/restsharp)上为维护人员提供支持，并通过提供资金激励他们.

### [#](https://restsharp.dev/support/#common-issues)Common issues

### [#](https://restsharp.dev/support/#common-issues)共同问题

Before opening an issue on GitHub, please check the list of known issues below.

在GitHub上打开问题之前，请查看下面的已知问题列表。

#### [#](https://restsharp.dev/support/#content-type)Content type

#### [#](https://restsharp.dev/support/#content-type)内容类型

One of the mistakes developers make when using RestSharp is setting the `Content-Type` header manually. Remember that in most of the usual scenarios setting the content type header manually is not required, and it might be harmful.

开发人员在使用RestSharp时犯的一个错误是手动设置`Content-Type`头。请记住，在大多数常见场景中，不需要手动设置内容类型标头，这可能是有害的。

RestSharp sets the content type header automatically based on the request type. You might want to override the request body content type, but the best way to do it is to supply the content type to the body parameter itself. Functions for adding the request body to the request have overloads, which accept content type. For example

RestSharp根据请求类型自动设置内容类型标头。您可能希望重写请求正文内容类型，但最好的方法是将内容类型提供给正文参数本身。用于将请求主体添加到请求的函数具有接受内容类型的重载。例如

```csharp
request.AddStringBody(jsonString, ContentType.Json);
```

#### [#](https://restsharp.dev/support/#setting-the-user-agent)Setting the User Agent

#### [#](https://restsharp.dev/support/#setting-the-user-agent)设置用户代理

Setting the user agent on the request won't work when you use `AddHeader`.

使用`AddHeader`时，在请求上设置用户代理将不起作用。

Instead, please use the `RestClientOptions.UserAgent` property.

相反地，请使用`RestClientOptions.UserAgent`属性。

#### [#](https://restsharp.dev/support/#empty-response)Empty response

#### [#](https://restsharp.dev/support/#empty-response)空响应

We regularly get issues where developers complain that their requests get executed and they get a proper raw response, but the `RestResponse<T>` instance doesn't have a deserialized object set.

我们经常遇到这样的问题：开发人员抱怨他们的请求被执行了，他们得到了正确的原始响应，但`RestResponse<T>`实例没有反序列化的对象集。

In other situations, the raw response is also empty.

在其他情况下，原始响应也是空的。

All those issues are caused by the design choice to swallow exceptions that occur when RestSharp makes the request and processes the response. Instead, RestSharp produces so-called *error response*.

所有这些问题都是由于RestSharp发出请求并处理响应时出现的吞咽异常的设计选择造成的。相反，RestSharp生成所谓的*错误响应*。

You can check the response status to find out if there are any errors. The following properties can tell you about those errors:

您可以检查响应状态以确定是否存在任何错误。以下属性可以告诉您这些错误：

- `IsSuccessful`
- `ResponseStatus`
- `StatusCode`
- `ErrorMessage`
- `ErrorException`

It could be that the request was executed and you got `200 OK` status code back and some content, but the typed `Data` property is empty.

可能是请求已执行，您得到了`200 OK`状态代码和一些内容，但类型化的`Data`属性为空。

In that case, you probably got deserialization issues. By default, RestSharp will just return an empty (`null`) result in the `Data` property. Deserialization errors can be also populated to the error response. To do that, set the `client.FailOnDeserializationError` property to `true`.

在这种情况下，您可能会遇到反序列化问题。默认情况下，RestSharp只会在`Data`属性中返回空（`null`）结果。反序列化错误也可以填充到错误响应中。为此，请将`client.FailOnDeserializationError` 属性设置为`true`。

It is also possible to force RestSharp to throw an exception.

也可以强制RestSharp抛出异常。

If you set `client.ThrowOnDeserializationError`, RestSharp will throw a `DeserializationException` when the serializer throws. The exception has the internal exception and the response.

如果你设置了`client.ThrowOnDeserializationError`,，RestSharp将在序列化程序抛出时抛出`DeserializationException`。

Finally, by setting `ThrowOnAnyError` you can force RestSharp to re-throw any exception that happens when making the request and processing the response.

最后，通过设置`ThrowOnAnyError`，您可以强制RestSharp重新抛出发出请求和处理响应时发生的任何异常。

[Help us by improving this page! open in new window](https://github.com/restsharp/RestSharp/edit/dev/docs/support/README.md)

Last Updated: 2022/7/21 17:09:28

Contributors: Marcel Juen

# N、流程图怎么画

| 标志 | 方向                  |
| :--- | :-------------------- |
| TB   | top bottom - 从上到下 |
| BT   | bottom top - 从下到上 |
| RL   | right left - 从右到左 |
| LR   | left right - 从左到右 |
| TD   | 等同于 TB             |

样式的含义：

- 有箭头：一般指数据流方向 -->
- 无箭头：仅表示相关性 --
- 实线：强关联 --
- 虚线：弱关联 -.-

~~~mermaid
graph TB
    1[开始] -.- 2[结束]
~~~
~~~mermaid
graph LR
	1[开始] --> 2[结束]
~~~

~~~mermaid
graph LR
    1[方形] --> 2(圆角) --> 3((圆形)) --> 4>非对称] --> 5{菱形} --> 6{{六角形}}
~~~

~~~mermaid
graph LR
1[\平行四边形\] --> 2[/平行四边形/] --> 3[/梯形\] --> 4[\梯形/]
~~~

~~~mermaid
graph LR
    1[begin] --- 2[end] -- 带文字的无向连接线 --- 3[ooooooo]
~~~

~~~mermaid
graph LR
    1[one] -.- 2[two] -.带文字的虚线.- 3[three] -.带文字和箭头的虚线.-> 4[four]
~~~

~~~mermaid
graph LR
    1[one] === 2[two] == 带文字粗箭头 ==> 3[three]
~~~

~~~mermaid
graph TB
    c1-->a2
    subgraph 第一组
    a1-->a2
    end
    subgraph 第二组
    b1-->b2
    b1-->a2
    end
    subgraph 第三组
    c1-->c2
    end
~~~

